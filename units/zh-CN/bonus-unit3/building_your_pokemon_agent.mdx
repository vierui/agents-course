# æ„å»ºä½ è‡ªå·±çš„å®å¯æ¢¦å¯¹æˆ˜æ™ºèƒ½ä½“

ç°åœ¨ä½ å·²ç»æ¢ç´¢äº†æ™ºèƒ½ä½“ AI åœ¨æ¸¸æˆä¸­çš„æ½œåŠ›å’Œå±€é™æ€§ï¼Œæ˜¯æ—¶å€™äº²è‡ªåŠ¨æ‰‹äº†ã€‚åœ¨æœ¬èŠ‚ä¸­ï¼Œä½ å°†**æ„å»ºè‡ªå·±çš„ AI æ™ºèƒ½ä½“æ¥è¿›è¡Œå®å¯æ¢¦é£æ ¼çš„å›åˆåˆ¶æˆ˜æ–—**ï¼Œä½¿ç”¨ä½ åœ¨æ•´ä¸ªè¯¾ç¨‹ä¸­å­¦åˆ°çš„ä¸€åˆ‡çŸ¥è¯†ã€‚

æˆ‘ä»¬å°†æŠŠç³»ç»Ÿåˆ†è§£ä¸ºå››ä¸ªå…³é”®æ„å»ºå—ï¼š

- **Poke-env:** ä¸€ä¸ªä¸“ä¸ºè®­ç»ƒåŸºäºè§„åˆ™æˆ–å¼ºåŒ–å­¦ä¹ çš„å®å¯æ¢¦æœºå™¨äººè€Œè®¾è®¡çš„ Python åº“ã€‚

- **PokÃ©mon Showdown:** ä¸€ä¸ªåœ¨çº¿å¯¹æˆ˜æ¨¡æ‹Ÿå™¨ï¼Œä½ çš„æ™ºèƒ½ä½“å°†åœ¨è¿™é‡Œæˆ˜æ–—ã€‚

- **LLMAgentBase:** æˆ‘ä»¬æ„å»ºçš„ä¸€ä¸ªè‡ªå®šä¹‰ Python ç±»ï¼Œç”¨äºå°†ä½ çš„ LLM ä¸ Poke-env æˆ˜æ–—ç¯å¢ƒè¿æ¥ã€‚

- **TemplateAgent:** ä¸€ä¸ªèµ·å§‹æ¨¡æ¿ï¼Œä½ å°†å®Œå–„å®ƒæ¥åˆ›å»ºè‡ªå·±ç‹¬ç‰¹çš„æˆ˜æ–—æ™ºèƒ½ä½“ã€‚

è®©æˆ‘ä»¬è¯¦ç»†æ¢ç´¢è¿™äº›ç»„ä»¶ã€‚

## ğŸ§  Poke-env

![Battle gif](https://github.com/hsahovic/poke-env/raw/master/rl-gif.gif)

[Poke-env](https://github.com/hsahovic/poke-env)æ˜¯ä¸€ä¸ª Python æ¥å£ï¼Œæœ€åˆç”±[Haris Sahovic](https://huggingface.co/hsahovic)æ„å»ºç”¨äºè®­ç»ƒå¼ºåŒ–å­¦ä¹ æœºå™¨äººï¼Œä½†æˆ‘ä»¬å·²å°†å…¶é‡æ–°ç”¨äºæ™ºèƒ½ä½“ AIã€‚
å®ƒå…è®¸ä½ çš„æ™ºèƒ½ä½“é€šè¿‡ç®€å•çš„ API ä¸ PokÃ©mon Showdown äº¤äº’ã€‚

å®ƒæä¾›äº†ä¸€ä¸ª`Player`ç±»ï¼Œä½ çš„æ™ºèƒ½ä½“å°†ç»§æ‰¿è¯¥ç±»ï¼Œæ¶µç›–ä¸å›¾å½¢ç•Œé¢é€šä¿¡æ‰€éœ€çš„ä¸€åˆ‡ã€‚

**æ–‡æ¡£**: [poke-env.readthedocs.io](https://poke-env.readthedocs.io/en/stable/)  
**ä»£ç åº“**: [github.com/hsahovic/poke-env](https://github.com/hsahovic/poke-env)

## âš”ï¸ PokÃ©mon Showdown

[PokÃ©mon Showdown](https://pokemonshowdown.com/)æ˜¯ä¸€ä¸ª[å¼€æº](https://github.com/smogon/Pokemon-Showdown)æˆ˜æ–—æ¨¡æ‹Ÿå™¨ï¼Œä½ çš„æ™ºèƒ½ä½“å°†åœ¨è¿™é‡Œè¿›è¡Œå®æ—¶å®å¯æ¢¦æˆ˜æ–—ã€‚
å®ƒæä¾›äº†ä¸€ä¸ªå®Œæ•´çš„ç•Œé¢æ¥å®æ—¶æ¨¡æ‹Ÿå’Œæ˜¾ç¤ºæˆ˜æ–—ã€‚åœ¨æˆ‘ä»¬çš„æŒ‘æˆ˜ä¸­ï¼Œä½ çš„æœºå™¨äººå°†åƒäººç±»ç©å®¶ä¸€æ ·è¡ŒåŠ¨ï¼Œé€å›åˆé€‰æ‹©æ‹›å¼ã€‚

æˆ‘ä»¬å·²ç»éƒ¨ç½²äº†ä¸€ä¸ªæ‰€æœ‰å‚ä¸è€…éƒ½å°†ä½¿ç”¨çš„æœåŠ¡å™¨æ¥è¿›è¡Œæˆ˜æ–—ã€‚è®©æˆ‘ä»¬çœ‹çœ‹è°èƒ½æ„å»ºå‡ºæœ€å¥½çš„ AI æˆ˜æ–—æ™ºèƒ½ä½“ï¼

**ä»£ç åº“**: [github.com/smogon/Pokemon-Showdown](https://github.com/smogon/Pokemon-Showdown)  
**ç½‘ç«™**: [pokemonshowdown.com](https://pokemonshowdown.com/)

## ğŸ”Œ LLMAgentBase

`LLMAgentBase`æ˜¯ä¸€ä¸ªæ‰©å±•äº†**Poke-env**ä¸­`Player`ç±»çš„ Python ç±»ã€‚
å®ƒä½œä¸ºä½ çš„**LLM**å’Œ**å®å¯æ¢¦æˆ˜æ–—æ¨¡æ‹Ÿå™¨**ä¹‹é—´çš„æ¡¥æ¢ï¼Œå¤„ç†è¾“å…¥/è¾“å‡ºæ ¼å¼åŒ–å¹¶ç»´æŠ¤æˆ˜æ–—ä¸Šä¸‹æ–‡ã€‚

è¿™ä¸ªåŸºç¡€æ™ºèƒ½ä½“æä¾›äº†ä¸€ç»„å·¥å…·ï¼ˆå®šä¹‰åœ¨`STANDARD_TOOL_SCHEMA`ä¸­ï¼‰æ¥ä¸ç¯å¢ƒäº¤äº’ï¼ŒåŒ…æ‹¬ï¼š

- `choose_move`: ç”¨äºåœ¨æˆ˜æ–—ä¸­é€‰æ‹©æ”»å‡»
- `choose_switch`: ç”¨äºåˆ‡æ¢å®å¯æ¢¦

LLM åº”è¯¥ä½¿ç”¨è¿™äº›å·¥å…·åœ¨æ¯”èµ›ä¸­åšå‡ºå†³ç­–ã€‚

### ğŸ§  æ ¸å¿ƒé€»è¾‘

- `choose_move(battle: Battle)`: è¿™æ˜¯æ¯å›åˆè°ƒç”¨çš„ä¸»è¦æ–¹æ³•ã€‚å®ƒæ¥æ”¶ä¸€ä¸ª`Battle`å¯¹è±¡å¹¶åŸºäº LLM çš„è¾“å‡ºè¿”å›ä¸€ä¸ªåŠ¨ä½œå­—ç¬¦ä¸²ã€‚

### ğŸ”§ å…³é”®å†…éƒ¨æ–¹æ³•

- `_format_battle_state(battle)`: å°†å½“å‰æˆ˜æ–—çŠ¶æ€è½¬æ¢ä¸ºå­—ç¬¦ä¸²ï¼Œä½¿å…¶é€‚åˆå‘é€ç»™ LLMã€‚

- `_find_move_by_name(battle, move_name)`: æŒ‰åç§°æŸ¥æ‰¾æ‹›å¼ï¼Œç”¨äº LLM å“åº”ä¸­è°ƒç”¨`choose_move`ã€‚

- `_find_pokemon_by_name(battle, pokemon_name)`: æ ¹æ® LLM çš„åˆ‡æ¢å‘½ä»¤å®šä½è¦åˆ‡æ¢åˆ°çš„ç‰¹å®šå®å¯æ¢¦ã€‚

- `_get_llm_decision(battle_state)`: è¿™ä¸ªæ–¹æ³•åœ¨åŸºç±»ä¸­æ˜¯æŠ½è±¡çš„ã€‚ä½ éœ€è¦åœ¨è‡ªå·±çš„æ™ºèƒ½ä½“ä¸­å®ç°å®ƒï¼ˆè§ä¸‹ä¸€èŠ‚ï¼‰ï¼Œåœ¨é‚£é‡Œä½ å®šä¹‰å¦‚ä½•æŸ¥è¯¢ LLM å¹¶è§£æå…¶å“åº”ã€‚

è¿™é‡Œæ˜¯æ˜¾ç¤ºå†³ç­–å¦‚ä½•å·¥ä½œçš„æ‘˜å½•ï¼š

```python
STANDARD_TOOL_SCHEMA = {
    "choose_move": {
        ...
    },
    "choose_switch": {
        ...
    },
}

class LLMAgentBase(Player):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.standard_tools = STANDARD_TOOL_SCHEMA
        self.battle_history = []

    def _format_battle_state(self, battle: Battle) -> str:
        active_pkmn = battle.active_pokemon
        active_pkmn_info = f"Your active Pokemon: {active_pkmn.species} " \
                           f"(Type: {'/'.join(map(str, active_pkmn.types))}) " \
                           f"HP: {active_pkmn.current_hp_fraction * 100:.1f}% " \
                           f"Status: {active_pkmn.status.name if active_pkmn.status else 'None'} " \
                           f"Boosts: {active_pkmn.boosts}"

        opponent_pkmn = battle.opponent_active_pokemon
        opp_info_str = "Unknown"
        if opponent_pkmn:
            opp_info_str = f"{opponent_pkmn.species} " \
                           f"(Type: {'/'.join(map(str, opponent_pkmn.types))}) " \
                           f"HP: {opponent_pkmn.current_hp_fraction * 100:.1f}% " \
                           f"Status: {opponent_pkmn.status.name if opponent_pkmn.status else 'None'} " \
                           f"Boosts: {opponent_pkmn.boosts}"
        opponent_pkmn_info = f"Opponent's active Pokemon: {opp_info_str}"

        available_moves_info = "Available moves:\n"
        if battle.available_moves:
            available_moves_info += "\n".join(
                [f"- {move.id} (Type: {move.type}, BP: {move.base_power}, Acc: {move.accuracy}, PP: {move.current_pp}/{move.max_pp}, Cat: {move.category.name})"
                 for move in battle.available_moves]
            )
        else:
             available_moves_info += "- None (Must switch or Struggle)"

        available_switches_info = "Available switches:\n"
        if battle.available_switches:
              available_switches_info += "\n".join(
                  [f"- {pkmn.species} (HP: {pkmn.current_hp_fraction * 100:.1f}%, Status: {pkmn.status.name if pkmn.status else 'None'})"
                   for pkmn in battle.available_switches]
              )
        else:
            available_switches_info += "- None"

        state_str = f"{active_pkmn_info}\n" \
                    f"{opponent_pkmn_info}\n\n" \
                    f"{available_moves_info}\n\n" \
                    f"{available_switches_info}\n\n" \
                    f"Weather: {battle.weather}\n" \
                    f"Terrains: {battle.fields}\n" \
                    f"Your Side Conditions: {battle.side_conditions}\n" \
                    f"Opponent Side Conditions: {battle.opponent_side_conditions}"
        return state_str.strip()

    def _find_move_by_name(self, battle: Battle, move_name: str) -> Optional[Move]:
        normalized_name = normalize_name(move_name)
        # ä¼˜å…ˆç²¾ç¡®IDåŒ¹é…
        for move in battle.available_moves:
            if move.id == normalized_name:
                return move
        # åå¤‡æ–¹æ¡ˆ: æ£€æŸ¥æ˜¾ç¤ºåç§°ï¼ˆä¸å¤ªå¯é ï¼‰
        for move in battle.available_moves:
            if move.name.lower() == move_name.lower():
                print(f"Warning: Matched move by display name '{move.name}' instead of ID '{move.id}'. Input was '{move_name}'.")
                return move
        return None

    def _find_pokemon_by_name(self, battle: Battle, pokemon_name: str) -> Optional[Pokemon]:
        normalized_name = normalize_name(pokemon_name)
        for pkmn in battle.available_switches:
            # è§„èŒƒåŒ–ç§ç±»åç§°ç”¨äºæ¯”è¾ƒ
            if normalize_name(pkmn.species) == normalized_name:
                return pkmn
        return None

    async def choose_move(self, battle: Battle) -> str:
        battle_state_str = self._format_battle_state(battle)
        decision_result = await self._get_llm_decision(battle_state_str)
        print(decision_result)
        decision = decision_result.get("decision")
        error_message = decision_result.get("error")
        action_taken = False
        fallback_reason = ""

        if decision:
            function_name = decision.get("name")
            args = decision.get("arguments", {})
            if function_name == "choose_move":
                move_name = args.get("move_name")
                if move_name:
                    chosen_move = self._find_move_by_name(battle, move_name)
                    if chosen_move and chosen_move in battle.available_moves:
                        action_taken = True
                        chat_msg = f"AI Decision: Using move '{chosen_move.id}'."
                        print(chat_msg)
                        return self.create_order(chosen_move)
                    else:
                        fallback_reason = f"LLM chose unavailable/invalid move '{move_name}'."
                else:
                     fallback_reason = "LLM 'choose_move' called without 'move_name'."
            elif function_name == "choose_switch":
                pokemon_name = args.get("pokemon_name")
                if pokemon_name:
                    chosen_switch = self._find_pokemon_by_name(battle, pokemon_name)
                    if chosen_switch and chosen_switch in battle.available_switches:
                        action_taken = True
                        chat_msg = f"AI Decision: Switching to '{chosen_switch.species}'."
                        print(chat_msg)
                        return self.create_order(chosen_switch)
                    else:
                        fallback_reason = f"LLM chose unavailable/invalid switch '{pokemon_name}'."
                else:
                    fallback_reason = "LLM 'choose_switch' called without 'pokemon_name'."
            else:
                fallback_reason = f"LLM called unknown function '{function_name}'."

        if not action_taken:
            if not fallback_reason:
                 if error_message:
                     fallback_reason = f"API Error: {error_message}"
                 elif decision is None:
                      fallback_reason = "LLM did not provide a valid function call."
                 else:
                      fallback_reason = "Unknown error processing LLM decision."

            print(f"Warning: {fallback_reason} Choosing random action.")

            if battle.available_moves or battle.available_switches:
                 return self.choose_random_move(battle)
            else:
                 print("AI Fallback: No moves or switches available. Using Struggle/Default.")
                 return self.choose_default_move(battle)

    async def _get_llm_decision(self, battle_state: str) -> Dict[str, Any]:
        raise NotImplementedError("Subclasses must implement _get_llm_decision")
```

**å®Œæ•´æºä»£ç **: [agents.py](https://huggingface.co/spaces/Jofthomas/twitch_streaming/blob/main/agents.py)

## ğŸ§ª TemplateAgent

ç°åœ¨åˆ°äº†æœ‰è¶£çš„éƒ¨åˆ†ï¼ä»¥ LLMAgentBase ä½œä¸ºä½ çš„åŸºç¡€ï¼Œæ˜¯æ—¶å€™å®ç°ä½ è‡ªå·±çš„æ™ºèƒ½ä½“äº†ï¼Œç”¨ä½ è‡ªå·±çš„ç­–ç•¥ç™»ä¸Šæ’è¡Œæ¦œã€‚

ä½ å°†ä»è¿™ä¸ªæ¨¡æ¿å¼€å§‹å¹¶æ„å»ºè‡ªå·±çš„é€»è¾‘ã€‚æˆ‘ä»¬è¿˜æä¾›äº†ä¸‰ä¸ªä½¿ç”¨**OpenAI**ã€**Mistral**å’Œ**Gemini**æ¨¡å‹çš„[å®Œæ•´ç¤ºä¾‹](https://huggingface.co/spaces/Jofthomas/twitch_streaming/blob/main/agents.py)æ¥æŒ‡å¯¼ä½ ã€‚

è¿™æ˜¯æ¨¡æ¿çš„ç®€åŒ–ç‰ˆæœ¬ï¼š

```python
class TemplateAgent(LLMAgentBase):
    """ä½¿ç”¨æ¨¡æ¿AI APIè¿›è¡Œå†³ç­–ã€‚"""
    def __init__(self, api_key: str = None, model: str = "model-name", *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.model = model
        self.template_client = TemplateModelProvider(api_key=...)
        self.template_tools = list(self.standard_tools.values())

    async def _get_llm_decision(self, battle_state: str) -> Dict[str, Any]:
        """Sends state to the LLM and gets back the function call decision."""
        system_prompt = (
            "You are a ..."
        )
        user_prompt = f"..."

        try:
            response = await self.template_client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt},
                ],
            )
            message = response.choices[0].message

            return {"decision": {"name": function_name, "arguments": arguments}}

        except Exception as e:
            print(f"Unexpected error during call: {e}")
            return {"error": f"Unexpected error: {e}"}
```

è¿™æ®µä»£ç æ— æ³•ç›´æ¥è¿è¡Œï¼Œå®ƒæ˜¯ä½ è‡ªå®šä¹‰é€»è¾‘çš„è“å›¾ã€‚

æœ‰äº†æ‰€æœ‰å‡†å¤‡å¥½çš„ç»„ä»¶ï¼Œç°åœ¨è½®åˆ°ä½ æ„å»ºä¸€ä¸ªæœ‰ç«äº‰åŠ›çš„æ™ºèƒ½ä½“äº†ã€‚åœ¨ä¸‹ä¸€èŠ‚ä¸­ï¼Œæˆ‘ä»¬å°†å±•ç¤ºå¦‚ä½•å°†ä½ çš„æ™ºèƒ½ä½“éƒ¨ç½²åˆ°æˆ‘ä»¬çš„æœåŠ¡å™¨å¹¶ä¸å…¶ä»–æ™ºèƒ½ä½“å®æ—¶å¯¹æˆ˜ã€‚

è®©æˆ˜æ–—å¼€å§‹å§ï¼ğŸ”¥
