# Construire un agent de combat Pok√©mon

Maintenant que vous avez explor√© le potentiel et les limitations de l'IA agentique dans les jeux vid√©os, il est temps de passer √† la pratique. Dans cette section, vous allez **construire votre propre agent pour combattre dans un combat au tour par tour dans le style de Pok√©mon**, en utilisant tout ce que vous avez appris √† travers le cours.

Nous d√©composerons le syst√®me en quatre blocs de construction cl√©s :

- **Poke-env :** Une biblioth√®que Python con√ßue pour entra√Æner des bots Pok√©mon bas√©s sur des r√®gles ou par apprentissage par renforcement.

- **Pok√©mon Showdown :** Un simulateur de combat en ligne o√π votre agent combattra.

- **LLMAgentBase :** Une classe Python personnalis√©e que nous avons construite pour connecter votre LLM avec l'environnement de combat *Poke-env*.

- **TemplateAgent :** Un *template* de d√©marrage que vous compl√©terez pour cr√©er votre propre agent de combat personnalis√©.

Explorons chacun de ces composants plus en d√©tail.

## üß† Poke-env

![Battle gif](https://github.com/hsahovic/poke-env/raw/master/rl-gif.gif)

[Poke-env](https://github.com/hsahovic/poke-env) est une interface Python originellement construite pour entra√Æner des bots d'apprentissage par renforcement par [Haris Sahovic](https://huggingface.co/hsahovic), mais nous l'avons r√©utilis√©e pour l'IA agentique.  
Elle permet √† votre agent d'interagir avec *Pok√©mon Showdown* √† travers une API simple.

Elle fournit une classe `Player` de laquelle votre agent h√©ritera, couvrant tout ce qui est n√©cessaire pour communiquer avec l'interface graphique.

**Documentation** : [poke-env.readthedocs.io](https://poke-env.readthedocs.io/en/stable/)  
**D√©p√¥t** : [github.com/hsahovic/poke-env](https://github.com/hsahovic/poke-env)

## ‚öîÔ∏è Pok√©mon Showdown

[Pok√©mon Showdown](https://pokemonshowdown.com/) est un simulateur de combat [*open-source*](https://github.com/smogon/Pokemon-Showdown) o√π votre agent jouera des combats Pok√©mon en direct.  
Il fournit une interface compl√®te pour simuler et afficher des combats en temps r√©el. Dans notre d√©fi, le bot agira exactement comme un joueur humain, choisissant des mouvements tour par tour.

Nous avons d√©ploy√© un serveur que tous les participants utiliseront pour combattre. Voyons qui construit le meilleur agent de combat !

**D√©p√¥t** : [github.com/smogon/Pokemon-Showdown](https://github.com/smogon/Pokemon-Showdown)  
**Site web** : [pokemonshowdown.com](https://pokemonshowdown.com/)

## üîå LLMAgentBase

`LLMAgentBase` est une classe Python qui √©tend la classe `Player` de **Poke-env**.  
Elle sert de pont entre votre **LLM** et le **simulateur de combat Pok√©mon**, g√©rant le formatage d'entr√©e/sortie et maintenant le contexte de combat.

Cet agent de base fournit un ensemble d'outils (d√©finis dans `STANDARD_TOOL_SCHEMA`) pour interagir avec l'environnement, incluant :

- `choose_move` : pour s√©lectionner une attaque pendant le combat  
- `choose_switch` : pour changer de Pok√©mon  

Le LLM devrait utiliser ces outils pour prendre des d√©cisions pendant un match.

### üß† Logique centrale

- `choose_move(battle: Battle)` : La m√©thode principale invoqu√©e √† chaque tour. Elle prend un objet `Battle` et retourne une cha√Æne d'action bas√©e sur la sortie du LLM.

### üîß M√©thodes internes cl√©s

- `_format_battle_state(battle)` : Convertit l'√©tat actuel du combat en cha√Æne, la rendant adapt√©e pour l'envoi au LLM.

- `_find_move_by_name(battle, move_name)` : Trouve un mouvement par nom, utilis√© dans les r√©ponses LLM qui appellent `choose_move`.

- `_find_pokemon_by_name(battle, pokemon_name)` : Localise un Pok√©mon sp√©cifique vers lequel changer, bas√© sur la commande de changement du LLM.

- `_get_llm_decision(battle_state)` : Cette m√©thode est abstraite dans la classe de base. Vous devrez l'impl√©menter dans votre propre agent (voir prochaine section), o√π vous d√©finissez comment interroger le LLM et analyser sa r√©ponse.

Voici un extrait montrant comment cette prise de d√©cision fonctionne :

```python
STANDARD_TOOL_SCHEMA = {
    "choose_move": {
        ...
    },
    "choose_switch": {
        ...
    },
}

class LLMAgentBase(Player):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.standard_tools = STANDARD_TOOL_SCHEMA
        self.battle_history = []

    def _format_battle_state(self, battle: Battle) -> str:
        active_pkmn = battle.active_pokemon
        active_pkmn_info = f"Your active Pokemon: {active_pkmn.species} " \
                           f"(Type: {'/'.join(map(str, active_pkmn.types))}) " \
                           f"HP: {active_pkmn.current_hp_fraction * 100:.1f}% " \
                           f"Status: {active_pkmn.status.name if active_pkmn.status else 'None'} " \
                           f"Boosts: {active_pkmn.boosts}"

        opponent_pkmn = battle.opponent_active_pokemon
        opp_info_str = "Unknown"
        if opponent_pkmn:
            opp_info_str = f"{opponent_pkmn.species} " \
                           f"(Type: {'/'.join(map(str, opponent_pkmn.types))}) " \
                           f"HP: {opponent_pkmn.current_hp_fraction * 100:.1f}% " \
                           f"Status: {opponent_pkmn.status.name if opponent_pkmn.status else 'None'} " \
                           f"Boosts: {opponent_pkmn.boosts}"
        opponent_pkmn_info = f"Opponent's active Pokemon: {opp_info_str}"

        available_moves_info = "Available moves:\n"
        if battle.available_moves:
            available_moves_info += "\n".join(
                [f"- {move.id} (Type: {move.type}, BP: {move.base_power}, Acc: {move.accuracy}, PP: {move.current_pp}/{move.max_pp}, Cat: {move.category.name})"
                 for move in battle.available_moves]
            )
        else:
             available_moves_info += "- None (Must switch or Struggle)"

        available_switches_info = "Available switches:\n"
        if battle.available_switches:
              available_switches_info += "\n".join(
                  [f"- {pkmn.species} (HP: {pkmn.current_hp_fraction * 100:.1f}%, Status: {pkmn.status.name if pkmn.status else 'None'})"
                   for pkmn in battle.available_switches]
              )
        else:
            available_switches_info += "- None"

        state_str = f"{active_pkmn_info}\n" \
                    f"{opponent_pkmn_info}\n\n" \
                    f"{available_moves_info}\n\n" \
                    f"{available_switches_info}\n\n" \
                    f"Weather: {battle.weather}\n" \
                    f"Terrains: {battle.fields}\n" \
                    f"Your Side Conditions: {battle.side_conditions}\n" \
                    f"Opponent Side Conditions: {battle.opponent_side_conditions}"
        return state_str.strip()

    def _find_move_by_name(self, battle: Battle, move_name: str) -> Optional[Move]:
        normalized_name = normalize_name(move_name)
        # Prioriser la correspondance exacte d'ID
        for move in battle.available_moves:
            if move.id == normalized_name:
                return move
        # Solution de secours : V√©rifier le nom d'affichage (moins fiable)
        for move in battle.available_moves:
            if move.name.lower() == move_name.lower():
                print(f"Warning: Matched move by display name '{move.name}' instead of ID '{move.id}'. Input was '{move_name}'.")
                return move
        return None

    def _find_pokemon_by_name(self, battle: Battle, pokemon_name: str) -> Optional[Pokemon]:
        normalized_name = normalize_name(pokemon_name)
        for pkmn in battle.available_switches:
            # Normaliser le nom d'esp√®ce pour la comparaison
            if normalize_name(pkmn.species) == normalized_name:
                return pkmn
        return None

    async def choose_move(self, battle: Battle) -> str:
        battle_state_str = self._format_battle_state(battle)
        decision_result = await self._get_llm_decision(battle_state_str)
        print(decision_result)
        decision = decision_result.get("decision")
        error_message = decision_result.get("error")
        action_taken = False
        fallback_reason = ""

        if decision:
            function_name = decision.get("name")
            args = decision.get("arguments", {})
            if function_name == "choose_move":
                move_name = args.get("move_name")
                if move_name:
                    chosen_move = self._find_move_by_name(battle, move_name)
                    if chosen_move and chosen_move in battle.available_moves:
                        action_taken = True
                        chat_msg = f"AI Decision: Using move '{chosen_move.id}'."
                        print(chat_msg)
                        return self.create_order(chosen_move)
                    else:
                        fallback_reason = f"LLM chose unavailable/invalid move '{move_name}'."
                else:
                     fallback_reason = "LLM 'choose_move' called without 'move_name'."
            elif function_name == "choose_switch":
                pokemon_name = args.get("pokemon_name")
                if pokemon_name:
                    chosen_switch = self._find_pokemon_by_name(battle, pokemon_name)
                    if chosen_switch and chosen_switch in battle.available_switches:
                        action_taken = True
                        chat_msg = f"AI Decision: Switching to '{chosen_switch.species}'."
                        print(chat_msg)
                        return self.create_order(chosen_switch)
                    else:
                        fallback_reason = f"LLM chose unavailable/invalid switch '{pokemon_name}'."
                else:
                    fallback_reason = "LLM 'choose_switch' called without 'pokemon_name'."
            else:
                fallback_reason = f"LLM called unknown function '{function_name}'."

        if not action_taken:
            if not fallback_reason:
                 if error_message:
                     fallback_reason = f"API Error: {error_message}"
                 elif decision is None:
                      fallback_reason = "LLM did not provide a valid function call."
                 else:
                      fallback_reason = "Unknown error processing LLM decision."

            print(f"Warning: {fallback_reason} Choosing random action.")

            if battle.available_moves or battle.available_switches:
                 return self.choose_random_move(battle)
            else:
                 print("AI Fallback: No moves or switches available. Using Struggle/Default.")
                 return self.choose_default_move(battle)

    async def _get_llm_decision(self, battle_state: str) -> Dict[str, Any]:
        raise NotImplementedError("Subclasses must implement _get_llm_decision")
```

**Code source complet** : [agents.py](https://huggingface.co/spaces/Jofthomas/twitch_streaming/blob/main/agents.py)

## üß™ TemplateAgent

Maintenant vient la partie amusante ! Avec `LLMAgentBase` comme fondation, il est temps d'impl√©menter votre propre agent, avec votre propre strat√©gie pour grimper dans le classement.

Vous commencerez √† partir de ce *template* et construirez votre propre logique. Nous avons aussi fourni trois [exemples complets](https://huggingface.co/spaces/Jofthomas/twitch_streaming/blob/main/agents.py) utilisant les mod√®les **OpenAI**, **Mistral** et **Gemini** pour vous guider.

Voici une version simplifi√©e du *template* :

```python
class TemplateAgent(LLMAgentBase):
    """Utilise l'API Template AI pour prendre des d√©cisions."""
    def __init__(self, api_key: str = None, model: str = "model-name", *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.model = model
        self.template_client = TemplateModelProvider(api_key=...)
        self.template_tools = list(self.standard_tools.values())

    async def _get_llm_decision(self, battle_state: str) -> Dict[str, Any]:
        """Envoie l'√©tat au LLM et re√ßoit en retour la d√©cision relative √† l'appel de fonction."""
        system_prompt = (
            "You are a ..."
        )
        user_prompt = f"..."

        try:
            response = await self.template_client.chat.completions.create(
                model=self.model,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt},
                ],
            )
            message = response.choices[0].message
            
            return {"decision": {"name": function_name, "arguments": arguments}}

        except Exception as e:
            print(f"Unexpected error during call: {e}")
            return {"error": f"Unexpected error: {e}"}
```

Ce code ne fonctionnera pas directement, c'est un plan pour votre cas personnalis√©.

Avec toutes les pi√®ces pr√™tes, c'est √† votre tour de construire un agent comp√©titif. Dans la prochaine section, nous montrerons comment d√©ployer votre agent sur notre serveur et combattre d'autres en temps r√©el.

Que le combat commence ! üî•