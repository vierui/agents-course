<CourseFloatingBanner 
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/#fileId=https://huggingface.co/agents-course/notebooks/blob/main/fr/unit2/smolagents/multiagent_notebook.ipynb"},
]}
askForHelpUrl="http://hf.co/join/discord" />

# SystÃ¨mes multi-agents

Les systÃ¨mes multi-agents permettent Ã  des **agents spÃ©cialisÃ©s de collaborer sur des tÃ¢ches complexes**, amÃ©liorant la modularitÃ©, la scalabilitÃ© et la robustesse. Au lieu de s'appuyer sur un seul agent, les tÃ¢ches sont distribuÃ©es entre des agents ayant des capacitÃ©s distinctes.

Dans `smolagents`, diffÃ©rents agents peuvent Ãªtre combinÃ©s pour gÃ©nÃ©rer du code Python, appeler des outils externes, effectuer des recherches web et plus encore. En orchestrant ces agents, nous pouvons crÃ©er des flux de travail puissants.

Une configuration typique pourrait inclure :
- Un **agent manageur** pour la dÃ©lÃ©gation des tÃ¢ches
- Un **agent interprÃ©teur de code** pour l'exÃ©cution de code
- Un **agent de recherche web** pour la rÃ©cupÃ©ration d'informations

Le diagramme ci-dessous illustre une architecture multi-agents simple oÃ¹ un **agent manageur** coordonne un **outil interprÃ©teur de code** et un **agent de recherche web**, qui Ã  son tour utilise des outils comme `DuckDuckGoSearchTool` et `VisitWebpageTool` pour rassembler des informations pertinentes.

<img src="https://mermaid.ink/img/pako:eNp1kc1qhTAQRl9FUiQb8wIpdNO76eKubrmFks1oRg3VSYgjpYjv3lFL_2hnMWQOJwn5sqgmelRWleUSKLAtFs09jqhtoWuYUFfFAa6QA9QDTnpzamheuhxn8pt40-6l13UtS0ddhtQXj6dbR4XUGQg6zEYasTF393KjeSDGnDJKNxzj8I_7hLW5IOSmP9CH9hv_NL-d94d4DVNg84p1EnK4qlIj5hGClySWbadT-6OdsrL02MI8sFOOVkciw8zx8kaNspxnrJQE0fXKtjBMMs3JA-MpgOQwftIE9Bzj14w-cMznI_39E9Z3p0uFoA?type=png" style='background: white;'>

## SystÃ¨mes multi-agents en action

Un systÃ¨me multi-agents se compose de plusieurs agents spÃ©cialisÃ©s travaillant ensemble sous la coordination d'un **agent orchestrateur**. Cette approche permet des flux de travail complexes en distribuant les tÃ¢ches entre des agents ayant des rÃ´les distincts.

Par exemple, un **systÃ¨me de RAG multi-agents** peut intÃ©grer :
- Un **agent web** pour naviguer sur internet.
- Un **agent rÃ©cupÃ©rateur** pour rÃ©cupÃ©rer des informations Ã  partir de bases de connaissances.
- Un **agent de gÃ©nÃ©ration d'images** pour produire des visuels.

Tous ces agents opÃ¨rent sous un orchestrateur qui gÃ¨re la dÃ©lÃ©gation de tÃ¢ches et l'interaction.

## RÃ©soudre une tÃ¢che complexe avec une hiÃ©rarchie multi-agents

> [!TIP]
> Vous pouvez suivre le code dans <a href="https://huggingface.co/agents-course/notebooks/blob/main/fr/unit2/smolagents/multiagent_notebook.ipynb" target="_blank">ce <i>notebook</i></a> que vous pouvez exÃ©cuter avec Google Colab.

La rÃ©ception approche ! Avec votre aide, Alfred a presque terminÃ© les prÃ©paratifs.

Mais maintenant il y a un problÃ¨me : la Batmobile a disparu. Alfred doit trouver une remplaÃ§ante, et la trouver rapidement.

Heureusement, quelques biographies ont Ã©tÃ© rÃ©alisÃ©es sur la vie de Bruce Wayne, alors peut-Ãªtre qu'Alfred pourrait rÃ©cupÃ©rer une voiture abandonnÃ©e sur l'un des plateaux de tournage et la reconditionner selon les normes modernes, ce qui inclurait certainement une option de conduite entiÃ¨rement autonome.

Mais cela pourrait Ãªtre n'importe oÃ¹ dans les lieux de tournage autour du monde ; pouvant Ãªtre nombreux.

Donc Alfred nÃ©cessite votre aide. Pourriez-vous construire un agent capable de rÃ©soudre cette tÃ¢che ?

> ğŸ‘‰ Trouvez tous les lieux de tournage de Batman dans le monde, calculez le temps de transfert par cargo jusqu'Ã  ces lieux, et reprÃ©sentez-les sur une carte, avec une couleur variant en fonction du temps de transfert par cargo. ReprÃ©sentez Ã©galement quelques usines de supercars avec le mÃªme temps de transfert en cargo.

Construisons cela !

Cet exemple nÃ©cessite des packages supplÃ©mentaires, donc installons-les d'abord :

```bash
pip install 'smolagents[litellm]' plotly geopandas shapely kaleido -q
```

### Nous crÃ©ons d'abord un outil pour obtenir le temps de transfert en avion cargo.

```python
import math
from typing import Optional, Tuple

from smolagents import tool


@tool
def calculate_cargo_travel_time(
    origin_coords: Tuple[float, float],
    destination_coords: Tuple[float, float],
    cruising_speed_kmh: Optional[float] = 750.0,  # Vitesse moyenne pour les avions cargo
) -> float:
    """
    Calcule le temps de voyage pour un avion cargo entre deux points sur Terre en utilisant la distance du grand cercle.

    Args:
        origin_coords: Tuple de (latitude, longitude) pour le point de dÃ©part
        destination_coords: Tuple de (latitude, longitude) pour la destination
        cruising_speed_kmh: Vitesse de croisiÃ¨re optionnelle en km/h (par dÃ©faut 750 km/h pour les avions cargo typiques)

    Returns:
        float: Le temps de voyage estimÃ© en heures

    Example:
        >>> # Chicago (41.8781Â° N, 87.6298Â° W) vers Sydney (33.8688Â° S, 151.2093Â° E)
        >>> result = calculate_cargo_travel_time((41.8781, -87.6298), (-33.8688, 151.2093))
    """

    def to_radians(degrees: float) -> float:
        return degrees * (math.pi / 180)

    # Extraire les coordonnÃ©es
    lat1, lon1 = map(to_radians, origin_coords)
    lat2, lon2 = map(to_radians, destination_coords)

    # Rayon de la Terre en kilomÃ¨tres
    EARTH_RADIUS_KM = 6371.0

    # Calculer la distance du grand cercle en utilisant la formule de haversine
    dlon = lon2 - lon1
    dlat = lat2 - lat1

    a = (
        math.sin(dlat / 2) ** 2
        + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2) ** 2
    )
    c = 2 * math.asin(math.sqrt(a))
    distance = EARTH_RADIUS_KM * c

    # Ajouter 10% pour tenir compte des routes non directes et des contrÃ´les de trafic aÃ©rien
    actual_distance = distance * 1.1

    # Calculer le temps de vol
    # Ajouter 1 heure pour les procÃ©dures de dÃ©collage et d'atterrissage
    flight_time = (actual_distance / cruising_speed_kmh) + 1.0

    # Formater les rÃ©sultats
    return round(flight_time, 2)


print(calculate_cargo_travel_time((41.8781, -87.6298), (-33.8688, 151.2093)))
```

### Configuration de l'agent

Pour le fournisseur de modÃ¨le, nous utilisons Together AI, l'un des nouveaux [fournisseurs d'infÃ©rence sur le Hub](https://huggingface.co/blog/inference-providers) !

Le `GoogleSearchTool` utilise l'[API Serper](https://serper.dev) pour rechercher sur le web, cela nÃ©cessite donc soit d'avoir configurÃ© la variable d'environnement `SERPAPI_API_KEY` et de passer `provider="serpapi"` ou d'avoir `SERPER_API_KEY` et de passer `provider=serper`.

Si vous n'avez pas de fournisseur Serp API configurÃ©, vous pouvez utiliser `DuckDuckGoSearchTool` mais attention il a une limite d'appels.

```python
import os
from PIL import Image
from smolagents import CodeAgent, GoogleSearchTool, InferenceClientModel, VisitWebpageTool

model = InferenceClientModel(model_id="Qwen/Qwen2.5-Coder-32B-Instruct", provider="together")
```

Nous pouvons commencer par crÃ©er un agent simple comme ligne de base pour nous donner un rapport simple.

```python
task = """Trouvez tous les lieux de tournage de Batman dans le monde, calculez le temps de transfert par avion cargo jusqu'ici (nous sommes Ã  Gotham, 40.7128Â° N, 74.0060Â° W), et renvoyez-les moi sous la forme d'un dataframe pandas.
Donnez-moi aussi des usines de supercars avec le mÃªme temps de transfert par avion-cargo."""
```

```python
agent = CodeAgent(
    model=model,
    tools=[GoogleSearchTool("serper"), VisitWebpageTool(), calculate_cargo_travel_time],
    additional_authorized_imports=["pandas"],
    max_steps=20,
)
```

```python
result = agent.run(task)
```

```python
result
```

Dans notre cas, il gÃ©nÃ¨re cette sortie :

```python
|  | Location                                             | Travel Time to Gotham (hours) |
|--|------------------------------------------------------|------------------------------|
| 0  | Necropolis Cemetery, Glasgow, Scotland, UK         | 8.60                         |
| 1  | St. George's Hall, Liverpool, England, UK         | 8.81                         |
| 2  | Two Temple Place, London, England, UK             | 9.17                         |
| 3  | Wollaton Hall, Nottingham, England, UK           | 9.00                         |
| 4  | Knebworth House, Knebworth, Hertfordshire, UK    | 9.15                         |
| 5  | Acton Lane Power Station, Acton Lane, Acton, UK  | 9.16                         |
| 6  | Queensboro Bridge, New York City, USA            | 1.01                         |
| 7  | Wall Street, New York City, USA                  | 1.00                         |
| 8  | Mehrangarh Fort, Jodhpur, Rajasthan, India       | 18.34                        |
| 9  | Turda Gorge, Turda, Romania                      | 11.89                        |
| 10 | Chicago, USA                                     | 2.68                         |
| 11 | Hong Kong, China                                 | 19.99                        |
| 12 | Cardington Studios, Northamptonshire, UK        | 9.10                         |
| 13 | Warner Bros. Leavesden Studios, Hertfordshire, UK | 9.13                         |
| 14 | Westwood, Los Angeles, CA, USA                  | 6.79                         |
| 15 | Woking, UK (McLaren)                             | 9.13                         |
```

Nous pourrions dÃ©jÃ  l'amÃ©liorer un peu en ajoutant des Ã©tapes de planification dÃ©diÃ©es et en ajoutant davantage de *prompts*.

Les Ã©tapes de planification permettent Ã  l'agent de penser Ã  l'avance et planifier ses prochaines Ã©tapes, ce qui peut Ãªtre utile pour des tÃ¢ches plus complexes.

```python
agent.planning_interval = 4

detailed_report = agent.run(f"""
Vous Ãªtes un analyste expert. Vous rÃ©digez des rapports complets aprÃ¨s avoir visitÃ© de nombreux sites web.
N'hÃ©sitez pas Ã  effectuer plusieurs recherches Ã  la fois dans une boucle for.
Pour chaque point de donnÃ©es que vous trouvez, visitez l'url source pour confirmer les chiffres.

{task}
""")

print(detailed_report)
```

```python
detailed_report
```

Dans notre cas, il gÃ©nÃ¨re cette sortie :

```python
|  | Location                                         | Travel Time (hours) |
|--|--------------------------------------------------|---------------------|
| 0  | Bridge of Sighs, Glasgow Necropolis, Glasgow, UK | 8.6                 |
| 1  | Wishart Street, Glasgow, Scotland, UK         | 8.6                 |
```

GrÃ¢ce Ã  ces changements rapides, nous avons obtenu un rapport beaucoup plus concis en fournissant simplement Ã  notre agent un *prompt* dÃ©taillÃ©, et en lui donnant des capacitÃ©s de planification !

La fenÃªtre de contexte du modÃ¨le se remplit rapidement. Donc **si nous demandons Ã  notre agent de combiner les rÃ©sultats de recherche dÃ©taillÃ©e avec une autre, il sera plus lent et cela augmentera rapidement le nombre de *tokens* utilisÃ©s et donc les coÃ»ts**.

â¡ï¸ Nous devons amÃ©liorer la structure de notre systÃ¨me.

### âœŒï¸ Diviser la tÃ¢che entre deux agents

Les structures multi-agents permettent de sÃ©parer les mÃ©moires entre diffÃ©rentes sous-tÃ¢ches, avec deux grands avantages :
- Chaque agent est davantage focalisÃ© sur sa tÃ¢che principale, donc plus performant
- SÃ©parer les mÃ©moires rÃ©duit le nombre de *tokens* d'entrÃ©e Ã  chaque Ã©tape, rÃ©duisant ainsi la latence et le coÃ»t.

CrÃ©ons une Ã©quipe avec un agent de recherche web dÃ©diÃ©, gÃ©rÃ© par un autre agent.

L'agent gestionnaire devrait avoir des capacitÃ©s de traÃ§age pour Ã©crire son rapport final : donnons-lui donc accÃ¨s Ã  des importations supplÃ©mentaires, incluant `plotly`, et `geopandas` + `shapely` pour le traÃ§age spatial.

```python
model = InferenceClientModel(
    "Qwen/Qwen2.5-Coder-32B-Instruct", provider="together", max_tokens=8096
)

web_agent = CodeAgent(
    model=model,
    tools=[
        GoogleSearchTool(provider="serper"),
        VisitWebpageTool(),
        calculate_cargo_travel_time,
    ],
    name="web_agent",
    description="Navigue sur le web pour trouver des informations",
    verbosity_level=0,
    max_steps=10,
)
```

L'agent gestionnaire aura besoin de faire du travail mental intensif.

Donc nous lui donnons le modÃ¨le plus puissant [DeepSeek-R1](https://huggingface.co/deepseek-ai/DeepSeek-R1), et ajoutons un `planning_interval` au mÃ©lange.

```python
from smolagents.utils import encode_image_base64, make_image_url
from smolagents import OpenAIServerModel


def check_reasoning_and_plot(final_answer, agent_memory):
    multimodal_model = OpenAIServerModel("gpt-4o", max_tokens=8096)
    filepath = "saved_map.png"
    assert os.path.exists(filepath), "Assurez-vous de sauvegarder le graphique sous saved_map.png !"
    image = Image.open(filepath)
    prompt = (
        f"Voici une tÃ¢che donnÃ©e par l'utilisateur et les Ã©tapes de l'agent : {agent_memory.get_succinct_steps()}. Maintenant voici le graphique qui a Ã©tÃ© fait."
        "Veuillez vÃ©rifier que le processus de raisonnement et le graphique sont corrects : rÃ©pondent-ils correctement Ã  la tÃ¢che donnÃ©e ?"
        "Listez d'abord les raisons pour lesquelles oui/non, puis Ã©crivez votre dÃ©cision finale : PASS en majuscules si c'est satisfaisant, FAIL si ce n'est pas le cas."
        "Ne soyez pas dur : si le graphique rÃ©sout principalement la tÃ¢che, il devrait passer."
        "Pour passer, un graphique devrait Ãªtre fait en utilisant px.scatter_map et non toute autre mÃ©thode (scatter_map a l'air plus joli)."
    )
    messages = [
        {
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": prompt,
                },
                {
                    "type": "image_url",
                    "image_url": {"url": make_image_url(encode_image_base64(image))},
                },
            ],
        }
    ]
    output = multimodal_model(messages).content
    print("Feedback: ", output)
    if "FAIL" in output:
        raise Exception(output)
    return True


manager_agent = CodeAgent(
    model=InferenceClientModel("deepseek-ai/DeepSeek-R1", provider="together", max_tokens=8096),
    tools=[calculate_cargo_travel_time],
    managed_agents=[web_agent],
    additional_authorized_imports=[
        "geopandas",
        "plotly",
        "shapely",
        "json",
        "pandas",
        "numpy",
    ],
    planning_interval=5,
    verbosity_level=2,
    final_answer_checks=[check_reasoning_and_plot],
    max_steps=15,
)
```

Inspectons Ã  quoi ressemble cette Ã©quipe :

```python
manager_agent.visualize()
```

Cela gÃ©nÃ©rera quelque chose comme ceci, nous aidant Ã  comprendre la structure et les relations entre les agents et les outils utilisÃ©s :

```python
CodeAgent | deepseek-ai/DeepSeek-R1
â”œâ”€â”€ âœ… Importations autorisÃ©es : ['geopandas', 'plotly', 'shapely', 'json', 'pandas', 'numpy']
â”œâ”€â”€ ğŸ› ï¸ Outils :
â”‚   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
â”‚   â”ƒ Nom                         â”ƒ Description                           â”ƒ Arguments                             â”ƒ
â”‚   â”¡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”©
â”‚   â”‚ calculate_cargo_travel_time â”‚ Calcule le temps de voyage pour un    â”‚ origin_coords (`array`) : Tuple de    â”‚
â”‚   â”‚                             â”‚ avion cargo entre deux points sur     â”‚ (latitude, longitude) pour le         â”‚
â”‚   â”‚                             â”‚ Terre en utilisant la distance du     â”‚ point de dÃ©part                       â”‚
â”‚   â”‚                             â”‚ grand cercle.                          â”‚ destination_coords (`array`) : Tuple  â”‚
â”‚   â”‚                             â”‚                                       â”‚ de (latitude, longitude) pour la      â”‚
â”‚   â”‚                             â”‚                                       â”‚ destination                           â”‚
â”‚   â”‚                             â”‚                                       â”‚ cruising_speed_kmh (`number`) :       â”‚
â”‚   â”‚                             â”‚                                       â”‚ Vitesse de croisiÃ¨re optionnelle      â”‚
â”‚   â”‚                             â”‚                                       â”‚ en km/h (par dÃ©faut 750 km/h pour     â”‚
â”‚   â”‚                             â”‚                                       â”‚ les avions cargo typiques)            â”‚
â”‚   â”‚ final_answer                â”‚ Fournit une rÃ©ponse finale au problÃ¨me â”‚ answer (`any`) : La rÃ©ponse finale    â”‚
â”‚   â”‚                             â”‚ donnÃ©.                                â”‚ au problÃ¨me                           â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€ ğŸ¤– Agents gÃ©rÃ©s :
    â””â”€â”€ web_agent | CodeAgent | Qwen/Qwen2.5-Coder-32B-Instruct
        â”œâ”€â”€ âœ… Importations autorisÃ©es : []
        â”œâ”€â”€ ğŸ“ Description : Navigue sur le web pour trouver des informations
        â””â”€â”€ ğŸ› ï¸ Outils :
            â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”³â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”“
            â”ƒ Nom                         â”ƒ Description                       â”ƒ Arguments                         â”ƒ
            â”¡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â•‡â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”©
            â”‚ web_search                  â”‚ Effectue une recherche web Google â”‚ query (`string`) : La requÃªte de  â”‚
            â”‚                             â”‚ pour votre requÃªte puis retourne  â”‚ recherche Ã  effectuer.            â”‚
            â”‚                             â”‚ une chaÃ®ne des meilleurs rÃ©sultats â”‚ filter_year (`integer`) :         â”‚
            â”‚                             â”‚ de recherche.                      â”‚ Optionnellement restreindre les   â”‚
            â”‚                             â”‚                                   â”‚ rÃ©sultats Ã  une certaine annÃ©e    â”‚
            â”‚ visit_webpage               â”‚ Visite une page web Ã  l'URL donnÃ©e â”‚ url (`string`) : L'URL de la page â”‚
            â”‚                             â”‚ et lit son contenu comme une      â”‚ web Ã  visiter.                    â”‚
            â”‚                             â”‚ chaÃ®ne markdown. Utilisez ceci    â”‚                                   â”‚
            â”‚                             â”‚ pour naviguer sur les pages web.  â”‚                                   â”‚
            â”‚ calculate_cargo_travel_time â”‚ Calcule le temps de voyage pour un â”‚ origin_coords (`array`) : Tuple de â”‚
            â”‚                             â”‚ avion cargo entre deux points sur â”‚ (latitude, longitude) pour le     â”‚
            â”‚                             â”‚ Terre en utilisant la distance du â”‚ point de dÃ©part                   â”‚
            â”‚                             â”‚ grand cercle.                      â”‚ destination_coords (`array`) :    â”‚
            â”‚                             â”‚                                   â”‚ Tuple de (latitude, longitude)    â”‚
            â”‚                             â”‚                                   â”‚ pour la destination               â”‚
            â”‚                             â”‚                                   â”‚ cruising_speed_kmh (`number`) :   â”‚
            â”‚                             â”‚                                   â”‚ Vitesse de croisiÃ¨re optionnelle  â”‚
            â”‚                             â”‚                                   â”‚ en km/h (par dÃ©faut 750 km/h pour â”‚
            â”‚                             â”‚                                   â”‚ les avions cargo typiques)        â”‚
            â”‚ final_answer                â”‚ Fournit une rÃ©ponse finale au     â”‚ answer (`any`) : La rÃ©ponse finale â”‚
            â”‚                             â”‚ problÃ¨me donnÃ©.                   â”‚ au problÃ¨me                       â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
manager_agent.run("""
Find all Batman filming locations in the world, calculate the time to transfer via cargo plane to here (we're in Gotham, 40.7128Â° N, 74.0060Â° W).
Also give me some supercar factories with the same cargo plane transfer time. You need at least 6 points in total.
Represent this as spatial map of the world, with the locations represented as scatter points with a color that depends on the travel time, and save it to saved_map.png!

Here's an example of how to plot and return a map:
import plotly.express as px
df = px.data.carshare()
fig = px.scatter_map(df, lat="centroid_lat", lon="centroid_lon", text="name", color="peak_hour", size=100,
     color_continuous_scale=px.colors.sequential.Magma, size_max=15, zoom=1)
fig.show()
fig.write_image("saved_image.png")
final_answer(fig)

Never try to process strings using code: when you have a string to read, just print it and you'll see it.
""")
```

Je ne sais pas comment cela s'est passÃ© pour votre exÃ©cution, mais dans la mienne, l'agent gestionnaire a habilement divisÃ© les tÃ¢ches donnÃ©es Ã  l'agent web en `1. Rechercher les lieux de tournage de Batman`, puis `2. Trouver les usines de supercars`, avant d'agrÃ©ger les listes et de tracer la carte.

Voyons Ã  quoi ressemble la carte en l'inspectant directement depuis l'Ã©tat de l'agent :

```python
manager_agent.python_executor.state["fig"]
```

Cela affichera la carte :

![Exemple de sortie de carte du systÃ¨me multi-agents](https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/smolagents/output_map.png)

## Ressources

- [SystÃ¨mes multi-agents](https://huggingface.co/docs/smolagents/main/en/examples/multiagents) â€“ AperÃ§u des systÃ¨mes multi-agents.
- [Qu'est-ce que le RAG agentique ?](https://weaviate.io/blog/what-is-agentic-rag) â€“ Introduction au RAG agentique.
- [SystÃ¨me RAG multi-agents ğŸ¤–ğŸ¤ğŸ¤– Recette](https://huggingface.co/learn/cookbook/multiagent_rag_system) â€“ Guide Ã©tape par Ã©tape pour construire un systÃ¨me RAG multi-agents.