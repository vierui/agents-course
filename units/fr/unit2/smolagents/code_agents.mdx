<CourseFloatingBanner
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/#fileId=https://huggingface.co/agents-course/notebooks/blob/main/fr/unit2/smolagents/code_agents.ipynb"},
]}
askForHelpUrl="http://hf.co/join/discord"
 />

# Construire des agents qui utilisent du code

Les agents Ã  code sont le type d'agent par dÃ©faut dans `smolagents`. Ils gÃ©nÃ¨rent des appels d'outils Python pour effectuer des actions, obtenant des reprÃ©sentations d'actions qui sont efficaces, expressives et prÃ©cises. 

Leur approche simplifiÃ©e rÃ©duit le nombre d'actions requises, simplifie les opÃ©rations complexes et permet la rÃ©utilisation de fonctions de code existantes. `smolagents` fournit un *framework* lÃ©ger pour construire de tels agents en environ 1 000 lignes de code.

![Code vs JSON Actions](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/transformers/code_vs_json_actions.png)
Graphique issu du papier [Executable Code Actions Elicit Better LLM Agents](https://huggingface.co/papers/2402.01030)

> [!TIP]
> Si vous voulez en savoir plus sur pourquoi les agents Ã  code sont efficaces, consultez <a href="https://huggingface.co/docs/smolagents/en/conceptual_guides/intro_agents#code-agents" target="_blank">ce guide</a> de la documentation smolagents.

## Pourquoi les agents Ã  code ?

Dans un processus d'agent multi-Ã©tapes, le LLM Ã©crit et exÃ©cute des actions, impliquant gÃ©nÃ©ralement des appels d'outils externes. Les approches traditionnelles utilisent un format JSON pour spÃ©cifier les noms d'outils et les arguments sous forme de chaÃ®nes, **que le systÃ¨me doit analyser pour dÃ©terminer quel outil exÃ©cuter**.

Cependant, la recherche montre que **les LLM d'appel d'outils fonctionnent plus efficacement avec du code directement**. C'est un principe fondamental de `smolagents`, comme le montre le diagramme ci-dessus issu de [*Executable Code Actions Elicit Better LLM Agents*](https://huggingface.co/papers/2402.01030).

Ã‰crire des actions en code plutÃ´t qu'en JSON offre plusieurs avantages clÃ©s :

* **ComposabilitÃ©** : Combiner et rÃ©utiliser facilement des actions
* **Gestion d'objets** : Travailler directement avec des structures complexes comme des images
* **GÃ©nÃ©ralitÃ©** : Exprimer toute tÃ¢che computationnellement possible
* **Naturel pour les LLM** : Du code de haute qualitÃ© est dÃ©jÃ  prÃ©sent dans les donnÃ©es d'entraÃ®nement des LLM

## Comment fonctionne un agent Ã  code ?

![From https://huggingface.co/docs/smolagents/conceptual_guides/react](https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/smolagents/codeagent_docs.png)

Le diagramme ci-dessus illustre comment `CodeAgent.run()` fonctionne, suivant le *framework* ReAct que nous avons mentionnÃ© dans l'UnitÃ© 1. L'abstraction principale pour les agents dans `smolagents` est un `MultiStepAgent` qui sert de bloc de construction principal. Comme nous le verrons dans un exemple ci-dessous, `CodeAgent` est un type spÃ©cial de `MultiStepAgent`.  

Un `CodeAgent` effectue des actions Ã  travers un cycle d'Ã©tapes (avec les variables existantes et les connaissances Ã©tant incorporÃ©es dans le contexte de l'agent) qui est conservÃ© dans un journal d'exÃ©cution :  

1. Le *prompt* systÃ¨me est stockÃ© dans un `SystemPromptStep` et la requÃªte utilisateur est enregistrÃ©e dans un `TaskStep`.

2. Ensuite, la boucle *while* suivante est exÃ©cutÃ©e :

    2.1 La mÃ©thode `agent.write_memory_to_messages()` Ã©crit les *logs* de l'agent dans une liste de [messages de chat](https://huggingface.co/docs/transformers/main/en/chat_templating) lisibles par le LLM.
    
    2.2 Ces messages sont envoyÃ©s Ã  un `Model` qui gÃ©nÃ¨re une complÃ©tion. 
    
    2.3 La complÃ©tion est analysÃ©e pour extraire l'action, qui, dans notre cas, devrait Ãªtre un extrait de code puisque nous travaillons avec un `CodeAgent`.  
    
    2.4 L'action est exÃ©cutÃ©e.
    
    2.5 Les rÃ©sultats sont enregistrÃ©s en mÃ©moire dans un `ActionStep`.

Ã€ la fin de chaque Ã©tape, si l'agent inclut des appels de fonction (dans `agent.step_callback`), ils sont exÃ©cutÃ©s.

## Voyons quelques exemples

> [!TIP]
> Vous pouvez suivre le code dans <a href="https://huggingface.co/agents-course/notebooks/blob/main/fr/unit2/smolagents/code_agents.ipynb" target="_blank">ce <i>notebook</i></a> que vous pouvez exÃ©cuter avec Google Colab.

Alfred planifie une fÃªte au manoir de la famille Wayne et a besoin de votre aide pour s'assurer que tout se passe bien. Pour l'aider, nous appliquerons ce que nous avons appris sur le fonctionnement d'un `CodeAgent` multi-Ã©tapes.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/smolagents/alfred-party.jpg" alt="Alfred Party"/>

Si vous n'avez pas encore installÃ© `smolagents`, vous pouvez le faire en exÃ©cutant la commande suivante :

```bash
pip install smolagents -U
```

Connectons-nous Ã©galement au Hub d'Hugging Face pour avoir accÃ¨s Ã  l'API d'infÃ©rence *Serverless*.

```python
from huggingface_hub import login

login()
```

### SÃ©lectionner une *playlist* pour la fÃªte en utilisant `smolagents`

La musique est un Ã©lÃ©ment essentiel d'une fÃªte rÃ©ussie ! Alfred a besoin d'aide pour sÃ©lectionner la *playlist*. Heureusement, `smolagents` nous couvre ! Nous pouvons construire un agent capable de rechercher sur le web en utilisant DuckDuckGo. Pour donner Ã  l'accÃ¨s Ã  cet outil  l'agent, nous l'incluons dans la liste des outils lors de la crÃ©ation de l'agent.

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/smolagents/alfred-playlist.jpg" alt="Alfred Playlist"/>

Pour le modÃ¨le, nous nous appuierons sur `InferenceClientModel`, qui fournit l'accÃ¨s Ã  l'[API d'infÃ©rence Serverless](https://huggingface.co/docs/api-inference/index) d'Hugging Face. Le modÃ¨le par dÃ©faut est `"Qwen/Qwen2.5-Coder-32B-Instruct"`, qui est performant et disponible pour une infÃ©rence rapide, mais vous pouvez sÃ©lectionner depuis le Hub n'importe quel modÃ¨le compatible.  

ExÃ©cuter un agent est assez simple :

```python
from smolagents import CodeAgent, DuckDuckGoSearchTool, InferenceClientModel

agent = CodeAgent(tools=[DuckDuckGoSearchTool()], model=InferenceClientModel())

agent.run("Recherche les meilleures recommandations musicales pour une fÃªte au manoir des Wayne.")
```

Lorsque vous exÃ©cutez cet exemple, la sortie **affichera une trace des Ã©tapes du *workflow* en cours d'exÃ©cution**. Elle affichera Ã©galement le code Python correspondant avec le message : 

```python
 â”€ Executing parsed code: â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
  results = web_search(query="best music for a Batman party")                                                      
  print(results)                                                                                                   
 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ 
```

AprÃ¨s quelques Ã©tapes, vous verrez la *playlist* gÃ©nÃ©rÃ©e qu'Alfred peut utiliser pour la fÃªte ! ğŸµ

### Utiliser un outil personnalisÃ© pour prÃ©parer le menu

<img src="https://huggingface.co/datasets/agents-course/course-images/resolve/main/en/unit2/smolagents/alfred-menu.jpg" alt="Alfred Menu"/>

Maintenant que nous avons sÃ©lectionnÃ© une *playlist*, nous devons organiser le menu pour les invitÃ©s. Encore une fois, Alfred peut tirer parti de `smolagents` pour le faire. Ici, nous utilisons le dÃ©corateur `@tool` pour dÃ©finir une fonction personnalisÃ©e qui agit comme un outil. Nous couvrirons la crÃ©ation d'outils plus en dÃ©tail plus tard, donc pour l'instant, nous pouvons simplement exÃ©cuter le code.

Comme vous pouvez le voir dans l'exemple ci-dessous, nous allons crÃ©er un outil en utilisant le dÃ©corateur `@tool` et l'inclure dans la liste `tools`.  

```python
from smolagents import CodeAgent, tool, InferenceClientModel

# Outil pour suggÃ©rer un menu basÃ© sur l'occasion
@tool
def suggest_menu(occasion: str) -> str:
    """
    SuggÃ¨re un menu basÃ© sur l'occasion.
    Args:
        occasion (str): Le type d'occasion pour la fÃªte. Les valeurs autorisÃ©es sont :
                        - "casual": Menu pour une fÃªte dÃ©contractÃ©e.
                        - "formal": Menu pour une fÃªte formelle.
                        - "superhero": Menu pour une fÃªte de super-hÃ©ros.
                        - "custom": Menu personnalisÃ©.
    """
    if occasion == "casual":
        return "Pizza, collations et boissons."
    elif occasion == "formal":
        return "DÃ®ner 3 services avec vin et dessert."
    elif occasion == "superhero":
        return "Buffet avec nourriture Ã©nergÃ©tique et saine."
    else:
        return "Menu personnalisÃ© pour le majordome."

# Alfred, le majordome, prÃ©parant le menu pour la fÃªte
agent = CodeAgent(tools=[suggest_menu], model=InferenceClientModel())

# PrÃ©parer le menu pour la fÃªte
agent.run("PrÃ©pare un menu formel pour la fÃªte.")
```

L'agent s'exÃ©cutera pendant quelques Ã©tapes jusqu'Ã  trouver la rÃ©ponse. PrÃ©ciser les valeurs autorisÃ©es dans la docstring aide Ã  diriger l'agent vers les valeurs d'argument `occasion` qui existent et limite les hallucinations.

Le menu est prÃªt ! ğŸ¥—

### Utiliser des imports Python Ã  l'intÃ©rieur de l'agent

Nous avons la *playlist* et le menu prÃªts, mais nous devons vÃ©rifier un dernier dÃ©tail crucial : le temps de prÃ©paration !

Alfred doit calculer quand tout serait prÃªt s'il commenÃ§ait Ã  prÃ©parer maintenant, au cas oÃ¹ ils auraient besoin de l'aide d'autres super-hÃ©ros.

`smolagents` est spÃ©cialisÃ© dans les agents qui Ã©crivent et exÃ©cutent des extraits de code Python, offrant une exÃ©cution sÃ©curisÃ©e.

En effet, **l'exÃ©cution du code a des mesures de sÃ©curitÃ© strictes** : les imports en dehors d'une liste sÃ»re prÃ©dÃ©finie sont bloquÃ©s par dÃ©faut. Cependant, vous pouvez autoriser des imports supplÃ©mentaires en les passant sous forme de chaÃ®nes dans `additional_authorized_imports`.
Pour plus de dÃ©tails sur l'exÃ©cution sÃ©curisÃ©e du code, consultez le [guide](https://huggingface.co/docs/smolagents/tutorials/secure_code_execution) officiel.

Lors de la crÃ©ation de l'agent, nous utiliserons `additional_authorized_imports` pour permettre l'importation du module `datetime`. 

```python
from smolagents import CodeAgent, InferenceClientModel
import numpy as np
import time
import datetime

agent = CodeAgent(tools=[], model=InferenceClientModel(), additional_authorized_imports=['datetime'])

agent.run(
    """
    Alfred doit se prÃ©parer pour la fÃªte. Voici les tÃ¢ches :
    1. PrÃ©parer les boissons - 30 minutes
    2. DÃ©corer le manoir - 60 minutes
    3. Mettre en place le menu - 45 minutes
    4. PrÃ©parer la musique et la playlist - 45 minutes

    Si nous commenÃ§ons maintenant, Ã  quelle heure la fÃªte sera-t-elle prÃªte ?
    """
)
```

Ces exemples ne sont que le dÃ©but de ce que vous pouvez faire avec les agents Ã  code, et nous commenÃ§ons dÃ©jÃ  Ã  voir leur utilitÃ© pour prÃ©parer la fÃªte. 
Vous pouvez en apprendre davantage sur la faÃ§on de construire de tels agents dans la [documentation de `smolagents`](https://huggingface.co/docs/smolagents).

En rÃ©sumÃ©, `smolagents` se spÃ©cialise dans les agents qui Ã©crivent et exÃ©cutent des extraits de code Python, offrant une exÃ©cution sÃ©curisÃ©e. Il supporte Ã  la fois les modÃ¨les de langage locaux et basÃ©s sur API, le rendant adaptable Ã  divers environnements de dÃ©veloppement.  

### Partager notre agent prÃ©parateur de fÃªte personnalisÃ© sur le Hub

Ne serait-il pas **incroyable de partager notre propre agent Alfred avec le reste du monde** ? En faisant cela, n'importe qui peut facilement tÃ©lÃ©charger et utiliser l'agent directement depuis le Hub, apportant l'ultime planificateur de fÃªte de Gotham Ã  portÃ©e de main ! Faisons-le ! ğŸ‰

La bibliothÃ¨que `smolagents` rend cela possible en vous permettant de partager un agent complet avec la communautÃ© et de tÃ©lÃ©charger ceux des autres pour une utilisation immÃ©diate. C'est aussi simple que ce qui suit :

```python
# Changez pour votre nom d'utilisateur et nom de dÃ©pÃ´t
agent.push_to_hub('sergiopaniego/AlfredAgent')
```

Pour tÃ©lÃ©charger Ã  nouveau l'agent, utilisez le code ci-dessous :

```python
# Changez pour votre nom d'utilisateur et nom de dÃ©pÃ´t
alfred_agent = agent.from_hub('sergiopaniego/AlfredAgent', trust_remote_code=True)

alfred_agent.run("Donne-moi la meilleure playlist pour une fÃªte au manoir des Wayne. L'idÃ©e de la fÃªte est un thÃ¨me 'mascarade de mÃ©chants'")  
```

Ce qui est Ã©galement excitant, c'est que les agents partagÃ©s sont directement disponibles en tant que *Spaces*, vous permettant d'interagir avec eux en temps rÃ©el. Vous pouvez explorer d'autres agents [ici](https://huggingface.co/spaces/davidberenstein1957/smolagents-and-tools).

Par exemple, l'_AlfredAgent_ est disponible [ici](https://huggingface.co/spaces/sergiopaniego/AlfredAgent). Vous pouvez l'essayer directement ci-dessous :

<iframe
	src="https://sergiopaniego-alfredagent.hf.space/"
	frameborder="0"
	width="850"
	height="450"
></iframe>

Vous vous demandez peut-Ãªtre comment Alfred a construit un tel agent en utilisant `smolagents` ? En intÃ©grant plusieurs outils, il peut gÃ©nÃ©rer un agent comme suit. Ne vous inquiÃ©tez pas des outils pour l'instant, car nous aurons une section dÃ©diÃ©e plus tard dans cette unitÃ© pour explorer cela en dÃ©tail :

```python
from smolagents import CodeAgent, DuckDuckGoSearchTool, FinalAnswerTool, InferenceClientModel, Tool, tool, VisitWebpageTool

@tool
def suggest_menu(occasion: str) -> str:
    """
    SuggÃ¨re un menu basÃ© sur l'occasion.
    Args:
        occasion: Le type d'occasion pour la fÃªte.
    """
    if occasion == "casual":
        return "Pizza, collations et boissons."
    elif occasion == "formal":
        return "DÃ®ner 3 services avec vin et dessert."
    elif occasion == "superhero":
        return "Buffet avec nourriture Ã©nergÃ©tique et saine."
    else:
        return "Menu personnalisÃ© pour le majordome."

@tool
def catering_service_tool(query: str) -> str:
    """
    Cet outil renvoie le service de restauration le mieux notÃ© Ã  Gotham City.
    
    Args:
        query: Un terme de recherche pour trouver des services de restauration.
    """
    # Exemple de liste de services de restauration et leurs notes
    services = {
        "Gotham Catering Co.": 4.9,
        "Wayne Manor Catering": 4.8,
        "Gotham City Events": 4.7,
    }
    
    # Trouver le service de restauration le mieux notÃ© (simuler le filtrage de requÃªte de recherche)
    best_service = max(services, key=services.get)
    
    return best_service

class SuperheroPartyThemeTool(Tool):
    name = "superhero_party_theme_generator"
    description = """
    Cet outil suggÃ¨re des idÃ©es crÃ©atives de fÃªte sur le thÃ¨me des super-hÃ©ros basÃ©es sur une catÃ©gorie.
    Il renvoie une idÃ©e de thÃ¨me de fÃªte unique."""
    
    inputs = {
        "category": {
            "type": "string",
            "description": "Le type de fÃªte de super-hÃ©ros (par ex., 'hÃ©ros classiques', 'mascarade de mÃ©chants', 'Gotham futuriste').",
        }
    }
    
    output_type = "string"

    def forward(self, category: str):
        themes = {
            "classic heroes": "Gala de la Justice League : Les invitÃ©s viennent habillÃ©s comme leurs hÃ©ros DC prÃ©fÃ©rÃ©s avec des cocktails thÃ©matiques comme 'Le Punch Kryptonite'.",
            "villain masquerade": "Bal des Voyous de Gotham : Une mascarade mystÃ©rieuse oÃ¹ les invitÃ©s s'habillent en mÃ©chants classiques de Batman.",
            "futuristic Gotham": "Nuit Neo-Gotham : Une fÃªte de style cyberpunk inspirÃ©e de Batman Beyond, avec des dÃ©corations nÃ©on et des gadgets futuristes."
        }
        
        return themes.get(category.lower(), "IdÃ©e de fÃªte thÃ©matique non trouvÃ©e. Essayez 'hÃ©ros classiques', 'mascarade de mÃ©chants', ou 'Gotham futuriste'.")


# Alfred, le majordome, prÃ©parant le menu pour la fÃªte
agent = CodeAgent(
    tools=[
        DuckDuckGoSearchTool(), 
        VisitWebpageTool(),
        suggest_menu,
        catering_service_tool,
        SuperheroPartyThemeTool(),
	FinalAnswerTool()
    ], 
    model=InferenceClientModel(),
    max_steps=10,
    verbosity_level=2
)

agent.run("Donne-moi la meilleure playlist pour une fÃªte au manoir des Wayne. L'idÃ©e de la fÃªte est un thÃ¨me 'mascarade de mÃ©chants'")
```

Comme vous pouvez le voir, nous avons crÃ©Ã© un `CodeAgent` avec plusieurs outils qui amÃ©liorent la fonctionnalitÃ© de l'agent, le transformant en l'ultime planificateur de fÃªte prÃªt Ã  partager avec la communautÃ© ! ğŸ‰

Maintenant, c'est Ã  votre tour : construisez votre propre agent et partagez-le avec la communautÃ© en utilisant les connaissances que nous venons d'apprendre ! ğŸ•µï¸â€â™‚ï¸ğŸ’¡

> [!TIP]
> Si vous souhaitez partager votre projet d'agent, crÃ©ez un <i>Space</i> et taguez <a href="https://huggingface.co/agents-course">agents-course</a> sur le Hub. Nous serions ravis de voir ce que vous avez crÃ©Ã© !

### Inspecter notre agent prÃ©parateur de fÃªte avec OpenTelemetry et Langfuse ğŸ“¡

Alors qu'Alfred peaufine l'agent, il se lasse de dÃ©boguer ses exÃ©cutions. Les agents, par nature, sont imprÃ©visibles et difficiles Ã  inspecter. Mais comme il vise Ã  construire l'ultime agent prÃ©parateur de fÃªte et Ã  le dÃ©ployer en production, il a besoin d'une traÃ§abilitÃ© robuste pour la surveillance et l'analyse futures.  

Encore une fois, `smolagents` vient Ã  la rescousse ! Il adopte la norme [OpenTelemetry](https://opentelemetry.io/) pour instrumenter les exÃ©cutions d'agents, permettant une inspection et une journalisation transparentes. Avec l'aide de [Langfuse](https://langfuse.com/) et du `SmolagentsInstrumentor`, Alfred peut facilement suivre et analyser le comportement de son agent.  

La configuration est simple !  

D'abord, nous devons installer les dÃ©pendances nÃ©cessaires :  

```bash
pip install opentelemetry-sdk opentelemetry-exporter-otlp openinference-instrumentation-smolagents langfuse
```

Ensuite, Alfred a dÃ©jÃ  crÃ©Ã© un compte sur Langfuse et a ses clÃ©s API prÃªtes. Si vous ne l'avez pas encore fait, vous pouvez vous inscrire Ã  Langfuse Cloud [ici](https://cloud.langfuse.com/) ou explorer des [alternatives](https://huggingface.co/docs/smolagents/tutorials/inspect_runs).  

Une fois que vous avez vos clÃ©s API, elles doivent Ãªtre correctement configurÃ©es comme suit :

```python
import os

# Obtenez les clÃ©s pour votre projet depuis la page des paramÃ¨tres du projet : https://cloud.langfuse.com
os.environ["LANGFUSE_PUBLIC_KEY"] = "pk-lf-..." 
os.environ["LANGFUSE_SECRET_KEY"] = "sk-lf-..." 
os.environ["LANGFUSE_HOST"] = "https://cloud.langfuse.com" # ğŸ‡ªğŸ‡º RÃ©gion UE
# os.environ["LANGFUSE_HOST"] = "https://us.cloud.langfuse.com" # ğŸ‡ºğŸ‡¸ RÃ©gion US
```

Avec les variables d'environnement dÃ©finies, nous pouvons maintenant initialiser le client Langfuse. `get_client()` initialise le client Langfuse en utilisant les identifiants fournis dans les variables d'environnement.

```python
from langfuse import get_client
 
langfuse = get_client()
 
# VÃ©rifier la connexion
if langfuse.auth_check():
    print("Le client Langfuse est authentifiÃ© et prÃªt !")
else:
    print("L'authentification a Ã©chouÃ©. Veuillez vÃ©rifier vos identifiants et l'hÃ´te.")
```

Enfin, Alfred est prÃªt Ã  initialiser le `SmolagentsInstrumentor` et commencer Ã  suivre les performances de son agent.  

```python
from openinference.instrumentation.smolagents import SmolagentsInstrumentor

SmolagentsInstrumentor().instrument()
```

Alfred est maintenant connectÃ© ğŸ”Œ ! Les exÃ©cutions de `smolagents` sont enregistrÃ©es dans Langfuse, lui donnant une visibilitÃ© complÃ¨te sur le comportement de l'agent. Avec cette configuration, il est prÃªt Ã  revisiter les exÃ©cutions prÃ©cÃ©dentes et Ã  affiner encore plus son agent prÃ©parateur de fÃªte. 

> [!TIP]
> Pour en savoir plus sur le traÃ§age de vos agents et l'utilisation des donnÃ©es collectÃ©es pour Ã©valuer leurs performances, consultez <a href="https://huggingface.co/learn/agents-course/fr/bonus-unit2/introduction">l'UnitÃ© Bonus 2</a>.

```python
from smolagents import CodeAgent, InferenceClientModel

agent = CodeAgent(tools=[], model=InferenceClientModel())
alfred_agent = agent.from_hub('sergiopaniego/AlfredAgent', trust_remote_code=True)
alfred_agent.run("Donne-moi la meilleure playlist pour une fÃªte au manoir des Wayne. L'idÃ©e de la fÃªte est un thÃ¨me 'mascarade de mÃ©chants'")  
```

Alfred peut maintenant accÃ©der aux logs [ici](https://cloud.langfuse.com/project/cm7bq0abj025rad078ak3luwi/traces/995fc019255528e4f48cf6770b0ce27b?timestamp=2025-02-19T10%3A28%3A36.929Z) pour les relire et les analyser.  

> [!TIP]
> En fait, une erreur mineure s'est produite lors de l'exÃ©cution. Pouvez-vous la repÃ©rer dans les logs ? Essayez de suivre comment l'agent la gÃ¨re et renvoie quand mÃªme une rÃ©ponse valide. <a href="https://cloud.langfuse.com/project/cm7bq0abj025rad078ak3luwi/traces/995fc019255528e4f48cf6770b0ce27b?timestamp=2025-02-19T10%3A28%3A36.929Z&observation=80ca57ace4f69b52">Voici</a> le lien direct vers l'erreur si vous voulez vÃ©rifier votre rÃ©ponse. Bien sÃ»r, l'erreur a Ã©tÃ© corrigÃ©e entre-temps, plus de dÃ©tails peuvent Ãªtre trouvÃ©s dans cette <a href="https://github.com/huggingface/smolagents/issues/838"><i>issue</i></a>.

Pendant ce temps, la [*playlist* suggÃ©rÃ©e](https://open.spotify.com/playlist/0gZMMHjuxMrrybQ7wTMTpw) crÃ©e l'ambiance parfaite pour les prÃ©paratifs de la fÃªte. Cool, non ? ğŸ¶  

---

Maintenant que nous avons crÃ©Ã© notre premier *Code Agent*, **apprenons comment nous pouvons crÃ©er des *Tool Calling Agents***, le deuxiÃ¨me type d'agent disponible dans `smolagents`.

## Ressources

- [Blog smolagents](https://huggingface.co/blog/smolagents) - Introduction Ã  smolagents et aux interactions de code
- [smolagents : Construire de bons agents](https://huggingface.co/docs/smolagents/tutorials/building_good_agents) - Meilleures pratiques pour des agents fiables
- [Construire des agents efficaces - Anthropic](https://www.anthropic.com/research/building-effective-agents) - Principes de conception d'agents
- [Partager des exÃ©cutions avec OpenTelemetry](https://huggingface.co/docs/smolagents/tutorials/inspect_runs) - DÃ©tails sur la faÃ§on de configurer OpenTelemetry pour suivre vos agents.
