<CourseFloatingBanner 
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/#fileId=https://huggingface.co/agents-course/notebooks/blob/main/fr/unit2/smolagents/retrieval_agents.ipynb"},
]}
askForHelpUrl="http://hf.co/join/discord" />

# Construction de systÃ¨mes de RAG agentiques

> [!TIP]
> Vous pouvez suivre le code dans <a href="https://huggingface.co/agents-course/notebooks/blob/main/fr/unit2/smolagents/retrieval_agents.ipynb" target="_blank">ce <i>notebook</i></a> que vous pouvez exÃ©cuter avec Google Colab.

Les systÃ¨mes de RAG (*Retrieval Augmented Generation*) combinent les capacitÃ©s de rÃ©cupÃ©ration de donnÃ©es et de modÃ¨les de gÃ©nÃ©ration pour fournir des rÃ©ponses contextuelles. Par exemple, la requÃªte d'un utilisateur est transmise Ã  un moteur de recherche puis les rÃ©sultats rÃ©cupÃ©rÃ©s sont fournis au LLM avec la requÃªte. Le modÃ¨le gÃ©nÃ¨re ensuite une rÃ©ponse basÃ©e sur la requÃªte et les informations rÃ©cupÃ©rÃ©es.

Le RAG agentique (*Agentic RAG*) Ã©tend les systÃ¨mes de RAG traditionnels en **combinant des agents autonomes avec une rÃ©cupÃ©ration dynamique des connaissances**. 

Alors que les systÃ¨mes de RAG traditionnels utilisent un LLM pour rÃ©pondre aux requÃªtes basÃ©es sur des donnÃ©es rÃ©cupÃ©rÃ©es, le RAG agentique **permet un contrÃ´le intelligent des processus de rÃ©cupÃ©ration et de gÃ©nÃ©ration**, amÃ©liorant l'efficacitÃ© et la prÃ©cision.

Les systÃ¨mes de RAG traditionnels font face Ã  des limitations clÃ©s, telles que **s'appuyer sur une seule Ã©tape de rÃ©cupÃ©ration** et se concentrer sur la similaritÃ© sÃ©mantique directe avec la requÃªte de l'utilisateur, ce qui peut nÃ©gliger des informations pertinentes.

Le RAG agentique rÃ©sout ces problÃ¨mes en permettant Ã  l'agent de formuler de maniÃ¨re autonome des requÃªtes, de critiquer les rÃ©sultats rÃ©cupÃ©rÃ©s et de mener plusieurs Ã©tapes de rÃ©cupÃ©ration pour une sortie plus adaptÃ©e et complÃ¨te.

## RÃ©cupÃ©ration de base avec DuckDuckGo

Construisons un agent simple qui peut rechercher sur le web en utilisant DuckDuckGo. Cet agent rÃ©cupÃ©rera des informations et synthÃ©tisera des rÃ©ponses pour rÃ©pondre aux requÃªtes. Avec le RAG agentique, l'agent d'Alfred peut :

* Rechercher des derniÃ¨res tendances en matiÃ¨re de fÃªtes de super-hÃ©ros
* Affiner les rÃ©sultats pour inclure des Ã©lÃ©ments luxueux
* SynthÃ©tiser les informations en un plan complet

Voici comment l'agent d'Alfred peut y parvenir :

```python
from smolagents import CodeAgent, DuckDuckGoSearchTool, InferenceClientModel

# Initialiser l'outil de recherche
search_tool = DuckDuckGoSearchTool()

# Initialiser le modÃ¨le
model = InferenceClientModel()

agent = CodeAgent(
    model=model,
    tools=[search_tool],
)

# Exemple d'utilisation
response = agent.run(
    "Search for luxury superhero-themed party ideas, including decorations, entertainment, and catering."
)
print(response)
```

L'agent suit ce processus :

1. **Analyse la requÃªte :** identifie les Ã©lÃ©ments clÃ©s de la requÃªte - organisation de fÃªtes de luxe sur le thÃ¨me des super-hÃ©ros, en mettant l'accent sur la dÃ©coration, les divertissements et la restauration.
2. **Effectue la rÃ©cupÃ©ration :** exploite DuckDuckGo pour rechercher les informations les plus pertinentes et Ã  jour, en s'assurant qu'elles correspondent aux prÃ©fÃ©rences d'Alfred pour un Ã©vÃ©nement luxueux.
3. **SynthÃ©tise l'information :** aprÃ¨s avoir rassemblÃ© les rÃ©sultats, l'agent les traite en un plan cohÃ©rent et actionnable pour Alfred, couvrant tous les aspects de la fÃªte.
4. **Stocke pour rÃ©fÃ©rence future :** stocke les informations rÃ©cupÃ©rÃ©es pour un accÃ¨s facile lors de la planification d'Ã©vÃ©nements futurs, optimisant l'efficacitÃ© des tÃ¢ches ultÃ©rieures.

## Outil de base de connaissances personnalisÃ©

Pour des tÃ¢ches spÃ©cialisÃ©es, une base de connaissances personnalisÃ©e peut Ãªtre inestimable. CrÃ©ons un outil qui interroge une base de donnÃ©es vectorielle de documentation technique ou de connaissances spÃ©cialisÃ©es. En utilisant la recherche sÃ©mantique, l'agent peut trouver les informations les plus pertinentes pour les besoins d'Alfred.

Une base de donnÃ©es vectorielle stocke des reprÃ©sentations numÃ©riques (*embeddings*) de texte ou d'autres donnÃ©es, crÃ©Ã©es par des modÃ¨les d'apprentissage automatique. Elle permet la recherche sÃ©mantique en identifiant des significations similaires dans un espace de haute dimension.

Cette approche combine des connaissances prÃ©dÃ©finies avec une recherche sÃ©mantique pour fournir des solutions contextuelles pour la planification d'Ã©vÃ©nements. Avec un accÃ¨s Ã  des connaissances spÃ©cialisÃ©es, Alfred peut perfectionner chaque dÃ©tail de la fÃªte.

Dans cet exemple, nous allons crÃ©er un outil qui rÃ©cupÃ¨re des idÃ©es de planification de fÃªte Ã  partir d'une base de connaissances personnalisÃ©e. Nous utiliserons un modÃ¨le BM25 pour rechercher dans la base de connaissances et retourner les meilleurs rÃ©sultats, et `RecursiveCharacterTextSplitter` pour diviser les documents en morceaux plus petits pour une recherche plus efficace.

```python
from langchain.docstore.document import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from smolagents import Tool
from langchain_community.retrievers import BM25Retriever
from smolagents import CodeAgent, InferenceClientModel

class PartyPlanningRetrieverTool(Tool):
    name = "party_planning_retriever"
    description = "Utilise la recherche sÃ©mantique pour trouver des idÃ©es pertinentes pour l'organisation de la fÃªte d'Alfred au Manoir Wayne sur le thÃ¨me des super-hÃ©ros."
    inputs = {
        "query": {
            "type": "string",
            "description": "La requÃªte Ã  effectuer. Celle-ci doit Ãªtre liÃ©e Ã  l'organisation de fÃªtes ou Ã  des thÃ¨mes de super-hÃ©ros.",
        }
    }
    output_type = "string"

    def __init__(self, docs, **kwargs):
        super().__init__(**kwargs)
        self.retriever = BM25Retriever.from_documents(
            docs, k=5  # RÃ©cupÃ©rer les 5 meilleurs documents
        )

    def forward(self, query: str) -> str:
        assert isinstance(query, str), "Votre requÃªte doit Ãªtre une chaÃ®ne de caractÃ¨res"

        docs = self.retriever.invoke(
            query,
        )
        return "\nIdÃ©es rÃ©cupÃ©rÃ©es :\n" + "".join(
            [
                f"\n\n===== IdÃ©e {str(i)} =====\n" + doc.page_content
                for i, doc in enumerate(docs)
            ]
        )

# Simuler une base de connaissances sur la planification de la fÃªte
party_ideas = [
    {"text": "Un bal masquÃ© sur le thÃ¨me des super-hÃ©ros avec un dÃ©cor luxueux, notamment des accents dorÃ©s et des rideaux de velours.", "source": "IdÃ©es de fÃªte 1"},
    {"text": "Engagez un DJ professionnel qui peut jouer de la musique sur le thÃ¨me des super-hÃ©ros comme Batman et Wonder Woman.", "source": "IdÃ©es de divertissement"},
    {"text": "Pour la restauration, servez des plats portant le nom de super-hÃ©ros, comme 'Le smoothie vert de Hulk' et 'Le steak de puissance d'Iron Man'", "source": "IdÃ©es de traiteur"},
    {"text": "DÃ©corez le lieu avec des logos de super-hÃ©ros emblÃ©matiques et des projections de Gotham et d'autres villes de super-hÃ©ros.", "source": "IdÃ©es de dÃ©coration"},
    {"text": "ExpÃ©riences interactives avec la VR oÃ¹ les invitÃ©s peuvent participer Ã  des simulations de super-hÃ©ros ou Ã  des jeux Ã  thÃ¨me.", "source": "IdÃ©es de divertissement"}
]

source_docs = [
    Document(page_content=doc["text"], metadata={"source": doc["source"]})
    for doc in party_ideas
]

# DÃ©couper les documents en morceaux plus petits pour une recherche plus efficace
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=500,
    chunk_overlap=50,
    add_start_index=True,
    strip_whitespace=True,
    separators=["\n\n", "\n", ".", " ", ""],
)
docs_processed = text_splitter.split_documents(source_docs)

# CrÃ©er l'outil de rÃ©cupÃ©ration
party_planning_retriever = PartyPlanningRetrieverTool(docs_processed)

# Initialiser l'agent
agent = CodeAgent(tools=[party_planning_retriever], model=InferenceClientModel())

# Exemple d'utilisation
response = agent.run(
    "Trouver des idÃ©es pour une fÃªte de luxe sur le thÃ¨me des super-hÃ©ros, y compris des options de divertissement, de restauration et de dÃ©coration."
)

print(response)
```

Cet agent amÃ©liorÃ© peut :
1. D'abord vÃ©rifier la documentation pour des informations pertinentes
2. Combiner les informations de la base de connaissances
3. Maintenir le contexte de conversation en mÃ©moire

## CapacitÃ©s de rÃ©cupÃ©ration amÃ©liorÃ©es

Lors de la construction de systÃ¨mes de RAG agentiques, l'agent peut employer des stratÃ©gies sophistiquÃ©es comme :

1. **La reformulation de requÃªte :** Au lieu d'utiliser la requÃªte brute de l'utilisateur, l'agent peut Ã©laborer des termes de recherche optimisÃ©s qui correspondent mieux aux documents cibles
2. **La dÃ©composition de requÃªte :** Au lieu d'utiliser directement la requÃªte de l'utilisateur, si elle contient plusieurs Ã©lÃ©ments d'information Ã  interroger, elle peut Ãªtre dÃ©composÃ©e en plusieurs requÃªtes
3. **L'expansion de requÃªte :** Similaire Ã  la reformulation de requÃªte mais effectuÃ©e plusieurs fois pour formuler la requÃªte de plusieurs faÃ§ons et les interroger toutes
4. **Le reclassement :** Utiliser des [*Cross-Encoders*](https://huggingface.co/models?pipeline_tag=text-ranking&sort=trending) pour attribuer des scores de pertinence sÃ©mantique plus complets entre les documents rÃ©cupÃ©rÃ©s et la requÃªte
5. **La rÃ©cupÃ©ration multi-Ã©tapes :** L'agent peut effectuer plusieurs recherches, en utilisant les rÃ©sultats initiaux pour informer les requÃªtes suivantes
6. **L'intÃ©gration de sources :** Les informations peuvent Ãªtre combinÃ©es Ã  partir de plusieurs sources comme la recherche web et la documentation locale
7. **La validation des rÃ©sultats :** Le contenu rÃ©cupÃ©rÃ© peut Ãªtre analysÃ© pour sa pertinence et son exactitude avant d'Ãªtre inclus dans les rÃ©ponses

Les systÃ¨mes de RAG agentiques efficaces nÃ©cessitent une considÃ©ration attentive de plusieurs aspects clÃ©s. L'agent **devrait sÃ©lectionner entre les outils disponibles en fonction du type de requÃªte et du contexte**. Les systÃ¨mes de mÃ©moire aident Ã  maintenir l'historique de conversation et Ã©vitent les rÃ©cupÃ©rations rÃ©pÃ©titives. Avoir des stratÃ©gies de secours garantit que le systÃ¨me peut toujours fournir de la valeur mÃªme lorsque les mÃ©thodes de rÃ©cupÃ©ration principales Ã©chouent. De plus, l'implÃ©mentation d'Ã©tapes de validation aide Ã  assurer l'exactitude et la pertinence des informations rÃ©cupÃ©rÃ©es.

## Ressources

- [Agentic RAG : boostez votre RAG avec la reformulation de requÃªte et l'auto-requÃªte ! ğŸš€](https://huggingface.co/learn/cookbook/agent_rag) - Recette pour dÃ©velopper un systÃ¨me de RAG agentique en utilisant `smolagents`.
