<CourseFloatingBanner 
  classNames="absolute z-10 right-0 top-0"
  notebooks={[
    {label: "Google Colab", value: "https://colab.research.google.com/#fileId=https://huggingface.co/agents-course/notebooks/blob/main/unit2/smolagents/retrieval_agents.ipynb"},
]}
askForHelpUrl="http://hf.co/join/discord" />

# Construction de systÃ¨mes RAG agentiques

<Tip>
Vous pouvez suivre le code dans <a href="https://huggingface.co/agents-course/notebooks/blob/main/unit2/smolagents/retrieval_agents.ipynb" target="_blank">ce notebook</a> que vous pouvez exÃ©cuter avec Google Colab.
</Tip>

Les systÃ¨mes de gÃ©nÃ©ration augmentÃ©e par rÃ©cupÃ©ration (*Retrieval Augmented Generation* ou *RAG*) combinent les capacitÃ©s de rÃ©cupÃ©ration de donnÃ©es et de modÃ¨les de gÃ©nÃ©ration pour fournir des rÃ©ponses contextuelles. Par exemple, la requÃªte d'un utilisateur est transmise Ã  un moteur de recherche, et les rÃ©sultats rÃ©cupÃ©rÃ©s sont fournis au modÃ¨le avec la requÃªte. Le modÃ¨le gÃ©nÃ¨re ensuite une rÃ©ponse basÃ©e sur la requÃªte et les informations rÃ©cupÃ©rÃ©es.

Le *RAG* agentique (*Agentic RAG*) Ã©tend les systÃ¨mes *RAG* traditionnels en **combinant des agents autonomes avec une rÃ©cupÃ©ration dynamique de connaissances**. 

Alors que les systÃ¨mes *RAG* traditionnels utilisent un *LLM* pour rÃ©pondre aux requÃªtes basÃ©es sur des donnÃ©es rÃ©cupÃ©rÃ©es, le *RAG* agentique **permet un contrÃ´le intelligent des processus de rÃ©cupÃ©ration et de gÃ©nÃ©ration**, amÃ©liorant l'efficacitÃ© et la prÃ©cision.

Les systÃ¨mes *RAG* traditionnels font face Ã  des limitations clÃ©s, telles que **s'appuyer sur une seule Ã©tape de rÃ©cupÃ©ration** et se concentrer sur la similaritÃ© sÃ©mantique directe avec la requÃªte de l'utilisateur, ce qui peut nÃ©gliger des informations pertinentes.

Le *RAG* agentique rÃ©sout ces problÃ¨mes en permettant Ã  l'agent de formuler de maniÃ¨re autonome des requÃªtes de recherche, de critiquer les rÃ©sultats rÃ©cupÃ©rÃ©s et de mener plusieurs Ã©tapes de rÃ©cupÃ©ration pour une sortie plus adaptÃ©e et complÃ¨te.

## RÃ©cupÃ©ration de base avec DuckDuckGo

Construisons un agent simple qui peut rechercher sur le web en utilisant DuckDuckGo. Cet agent rÃ©cupÃ©rera des informations et synthÃ©tisera des rÃ©ponses pour rÃ©pondre aux requÃªtes. Avec le *RAG* agentique, l'agent d'Alfred peut :

* Rechercher les derniÃ¨res tendances de fÃªtes de super-hÃ©ros
* Affiner les rÃ©sultats pour inclure des Ã©lÃ©ments de luxe
* SynthÃ©tiser les informations en un plan complet

Voici comment l'agent d'Alfred peut y parvenir :

```python
from smolagents import CodeAgent, DuckDuckGoSearchTool, InferenceClientModel

# Initialiser l'outil de recherche
search_tool = DuckDuckGoSearchTool()

# Initialiser le modÃ¨le
model = InferenceClientModel()

agent = CodeAgent(
    model=model,
    tools=[search_tool],
)

# Exemple d'utilisation
response = agent.run(
    "Search for luxury superhero-themed party ideas, including decorations, entertainment, and catering."
)
print(response)
```

L'agent suit ce processus :

1. **Analyse la requÃªte :** L'agent d'Alfred identifie les Ã©lÃ©ments clÃ©s de la requÃªte - planification de fÃªte Ã  thÃ¨me de super-hÃ©ros de luxe, avec un accent sur la dÃ©coration, le divertissement et le traiteur.
2. **Effectue la rÃ©cupÃ©ration :** L'agent exploite DuckDuckGo pour rechercher les informations les plus pertinentes et Ã  jour, en s'assurant qu'elles correspondent aux prÃ©fÃ©rences raffinÃ©es d'Alfred pour un Ã©vÃ©nement luxueux.
3. **SynthÃ©tise l'information :** AprÃ¨s avoir rassemblÃ© les rÃ©sultats, l'agent les traite en un plan cohÃ©rent et actionnable pour Alfred, couvrant tous les aspects de la fÃªte.
4. **Stocke pour rÃ©fÃ©rence future :** L'agent stocke les informations rÃ©cupÃ©rÃ©es pour un accÃ¨s facile lors de la planification d'Ã©vÃ©nements futurs, optimisant l'efficacitÃ© des tÃ¢ches ultÃ©rieures.

## Outil de base de connaissances personnalisÃ©

Pour des tÃ¢ches spÃ©cialisÃ©es, une base de connaissances personnalisÃ©e peut Ãªtre inestimable. CrÃ©ons un outil qui interroge une base de donnÃ©es vectorielle de documentation technique ou de connaissances spÃ©cialisÃ©es. En utilisant la recherche sÃ©mantique, l'agent peut trouver les informations les plus pertinentes pour les besoins d'Alfred.

Une base de donnÃ©es vectorielle stocke des reprÃ©sentations numÃ©riques (*embeddings*) de texte ou d'autres donnÃ©es, crÃ©Ã©es par des modÃ¨les d'apprentissage automatique. Elle permet la recherche sÃ©mantique en identifiant des significations similaires dans un espace de haute dimension.

Cette approche combine des connaissances prÃ©dÃ©finies avec une recherche sÃ©mantique pour fournir des solutions contextuelles pour la planification d'Ã©vÃ©nements. Avec un accÃ¨s Ã  des connaissances spÃ©cialisÃ©es, Alfred peut perfectionner chaque dÃ©tail de la fÃªte.

Dans cet exemple, nous allons crÃ©er un outil qui rÃ©cupÃ¨re des idÃ©es de planification de fÃªte Ã  partir d'une base de connaissances personnalisÃ©e. Nous utiliserons un rÃ©cupÃ©rateur BM25 pour rechercher dans la base de connaissances et retourner les meilleurs rÃ©sultats, et `RecursiveCharacterTextSplitter` pour diviser les documents en morceaux plus petits pour une recherche plus efficace.

```python
from langchain.docstore.document import Document
from langchain.text_splitter import RecursiveCharacterTextSplitter
from smolagents import Tool
from langchain_community.retrievers import BM25Retriever
from smolagents import CodeAgent, InferenceClientModel

class PartyPlanningRetrieverTool(Tool):
    name = "party_planning_retriever"
    description = "Utilise la recherche sÃ©mantique pour rÃ©cupÃ©rer des idÃ©es pertinentes de planification de fÃªte pour la fÃªte Ã  thÃ¨me de super-hÃ©ros d'Alfred au Wayne Manor."
    inputs = {
        "query": {
            "type": "string",
            "description": "La requÃªte Ã  effectuer. Cela devrait Ãªtre une requÃªte liÃ©e Ã  la planification de fÃªte ou aux thÃ¨mes de super-hÃ©ros.",
        }
    }
    output_type = "string"

    def __init__(self, docs, **kwargs):
        super().__init__(**kwargs)
        self.retriever = BM25Retriever.from_documents(
            docs, k=5  # RÃ©cupÃ©rer les 5 meilleurs documents
        )

    def forward(self, query: str) -> str:
        assert isinstance(query, str), "Votre requÃªte de recherche doit Ãªtre une chaÃ®ne de caractÃ¨res"

        docs = self.retriever.invoke(
            query,
        )
        return "\nIdÃ©es rÃ©cupÃ©rÃ©es :\n" + "".join(
            [
                f"\n\n===== IdÃ©e {str(i)} =====\n" + doc.page_content
                for i, doc in enumerate(docs)
            ]
        )

# Simuler une base de connaissances sur la planification de fÃªte
party_ideas = [
    {"text": "Un bal masquÃ© Ã  thÃ¨me de super-hÃ©ros avec dÃ©cor de luxe, incluant des accents dorÃ©s et des rideaux de velours.", "source": "IdÃ©es de fÃªte 1"},
    {"text": "Engager un DJ professionnel qui peut jouer de la musique Ã  thÃ¨me pour des super-hÃ©ros comme Batman et Wonder Woman.", "source": "IdÃ©es de divertissement"},
    {"text": "Pour le traiteur, servir des plats nommÃ©s d'aprÃ¨s des super-hÃ©ros, comme 'Le Smoothie Vert de Hulk' et 'Le Steak de Puissance d'Iron Man'.", "source": "IdÃ©es de traiteur"},
    {"text": "DÃ©corer avec des logos de super-hÃ©ros emblÃ©matiques et des projections de Gotham et d'autres villes de super-hÃ©ros autour du lieu.", "source": "IdÃ©es de dÃ©coration"},
    {"text": "ExpÃ©riences interactives avec VR oÃ¹ les invitÃ©s peuvent s'engager dans des simulations de super-hÃ©ros ou concourir dans des jeux Ã  thÃ¨me.", "source": "IdÃ©es de divertissement"}
]

source_docs = [
    Document(page_content=doc["text"], metadata={"source": doc["source"]})
    for doc in party_ideas
]

# Diviser les documents en morceaux plus petits pour une recherche plus efficace
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=500,
    chunk_overlap=50,
    add_start_index=True,
    strip_whitespace=True,
    separators=["\n\n", "\n", ".", " ", ""],
)
docs_processed = text_splitter.split_documents(source_docs)

# CrÃ©er l'outil de rÃ©cupÃ©ration
party_planning_retriever = PartyPlanningRetrieverTool(docs_processed)

# Initialiser l'agent
agent = CodeAgent(tools=[party_planning_retriever], model=InferenceClientModel())

# Exemple d'utilisation
response = agent.run(
    "Find ideas for a luxury superhero-themed party, including entertainment, catering, and decoration options."
)

print(response)
```

Cet agent amÃ©liorÃ© peut :
1. D'abord vÃ©rifier la documentation pour des informations pertinentes
2. Combiner les insights de la base de connaissances
3. Maintenir le contexte de conversation en mÃ©moire

## CapacitÃ©s de rÃ©cupÃ©ration amÃ©liorÃ©es

Lors de la construction de systÃ¨mes *RAG* agentiques, l'agent peut employer des stratÃ©gies sophistiquÃ©es comme :

1. **Reformulation de requÃªte :** Au lieu d'utiliser la requÃªte brute de l'utilisateur, l'agent peut crÃ©er des termes de recherche optimisÃ©s qui correspondent mieux aux documents cibles
2. **DÃ©composition de requÃªte :** Au lieu d'utiliser directement la requÃªte de l'utilisateur, si elle contient plusieurs Ã©lÃ©ments d'information Ã  interroger, elle peut Ãªtre dÃ©composÃ©e en plusieurs requÃªtes
3. **Expansion de requÃªte :** Similaire Ã  la reformulation de requÃªte mais effectuÃ©e plusieurs fois pour formuler la requÃªte de plusieurs faÃ§ons et les interroger toutes
4. **Reclassement :** Utiliser des *Cross-Encoders* pour attribuer des scores de pertinence sÃ©mantique plus complets entre les documents rÃ©cupÃ©rÃ©s et la requÃªte de recherche
5. **RÃ©cupÃ©ration multi-Ã©tapes :** L'agent peut effectuer plusieurs recherches, en utilisant les rÃ©sultats initiaux pour informer les requÃªtes suivantes
6. **IntÃ©gration de sources :** Les informations peuvent Ãªtre combinÃ©es Ã  partir de plusieurs sources comme la recherche web et la documentation locale
7. **Validation des rÃ©sultats :** Le contenu rÃ©cupÃ©rÃ© peut Ãªtre analysÃ© pour sa pertinence et son exactitude avant d'Ãªtre inclus dans les rÃ©ponses

Les systÃ¨mes *RAG* agentiques efficaces nÃ©cessitent une considÃ©ration attentive de plusieurs aspects clÃ©s. L'agent **devrait sÃ©lectionner entre les outils disponibles en fonction du type de requÃªte et du contexte**. Les systÃ¨mes de mÃ©moire aident Ã  maintenir l'historique de conversation et Ã©vitent les rÃ©cupÃ©rations rÃ©pÃ©titives. Avoir des stratÃ©gies de secours garantit que le systÃ¨me peut toujours fournir de la valeur mÃªme lorsque les mÃ©thodes de rÃ©cupÃ©ration principales Ã©chouent. De plus, l'implÃ©mentation d'Ã©tapes de validation aide Ã  assurer l'exactitude et la pertinence des informations rÃ©cupÃ©rÃ©es.

## Ressources

- [Agentic RAG : boostez votre RAG avec la reformulation de requÃªte et l'auto-requÃªte ! ğŸš€](https://huggingface.co/learn/cookbook/agent_rag) - Recette pour dÃ©velopper un systÃ¨me *RAG* agentique en utilisant smolagents.